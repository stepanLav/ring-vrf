
\section{Ring Verifiable Random Function in the UC Model}
\label{subsec:uc_model}

In this section, we define the security of  a ring VRF protocol in the UC model \cite{canetti1,canetti2}. We introduce a ring VRF functionality $ \fgvrf $ satisfying the security properties we want to achieve in a ring VRF. These properties are informally as follows: \emph{randomness} meaning that an evaluation value is random and independent from the message, ring and the public key, \emph{determinism} meaning that $ \rVRF.\Eval $ is deterministic, \emph{anonymity} meaning that $ \rVRF.\Sign $ does not give information about its signer, \emph{unforgeability} meaning that an adversary should not generate a forged signature and \emph{uniqueness} meaning that number of verified evaluation values should not be more than the number of the keys in the ring.
In Figure \ref{f:gvrf}, we give a UC functionality $\fgvrf$ that provides these security properties.  
%In $\fgvrf$, we suppress
%associated data and ring commitment details to make our UC functionality
%more accessible, meaning our ring commitment is simply the full ring. We introduce more variations of ring VRF functionalities in Appendix \ref{sec:morefuncs} with additional security properties.
Here are several important remarks that help elucidate $\fgvrf$ in Figure \ref{f:gvrf}:



\begin{enumerate}[label={{R-} }{{\arabic*}}, start = 1]
	\item Each party is distinguished by a unique verification key which is given by the simulator. Verification keys have the identifier role of  the signatures and outputs rather than  influencing the value of them. Therefore, there exists no secret key as in the real world protocol. \eprint{We note that we need to define verification keys in $ \fgvrf $ because the real world protocol $ \rVRF $ defines a verification key (or public key) for each party.}{}
	
	\item In ring VRF, the verification algorithm outputs the corresponding evaluation value of the verified signature. Therefore, $ \fgvrf $  outputs the corresponding output during the signature verification if the signature is verified. However, it achieves this together with the anonymous key which is not defined in the ring VRF in the real world.  If $ \fgvrf $ did not define an anonymous key of each signature, then there would be no way that $ \fgvrf $ determines the actual verification key of the signature $ \sigma $ and outputs the evaluation value because $ \sigma $ does not need to be associated with the signer's key. Therefore, $ \fgvrf $ maps a random anonymous key to each $ \msg $ and $ \pk $ so that this key behaves as if it is the verification key of the signature. Since it  is  random and independent from $ \msg $ and $ \pk $, it does not leak any information about the signer during the verification but it still allows $ \fgvrf $ to distinguish the signer.
	
	\item $ \fgvrf $ does not have a separate signing protocol for malicious parties as honest parties because they can generate it as they want. If they generate a signature, it is added to the $ \fgvrf $'s records as valid or invalid when an honest party sends a verification message of it.  Its validity depends on $ \simulator $ as it can be seen in  the condition C\ref{cond:malicioussignature} in Figure \ref{f:gvrf}. 
	
	\item Once $ \simulator $ obtains an anonymous key $ W $ of a message $ \msg $ generated for an honest party with a key $ \pk $, we let $ \simulator $ learn the  evaluation of  $ \msg $ with $ \pk $ without knowing the $ \pk $. $ \simulator $ can do this via malicious ring VRF evaluation i.e., send the message $ (\oramsg{eval}, \sid, \pk_i,W,\msg) $ where $ \pk_i $ is a malicious verification key. Here, if $ W $ is an anonymous key of $ \msg, \pk  $, $ \fgvrf $ returns $ \evaluationslist[\msg, W] $ even if $ \pk \neq \pk_i $. 
	%$ \fgvrf $ returns it independent from which verification key given in $ \simulator $'s message. 
	
	\item Once $ \simulator $ obtains an anonymous key of a message $ \msg $ generated for an honest party, it can learn all valid signatures generated by $ W $ for a ring $ \ring $ and $ \msg $ via malicious requests of signatures.
	
	\item Each honest party's public key $ \pk $ is associated with a unique key $ x $ which is only used to generate honest signatures by $ \Gen_{sign} $. It is never shared with honest parties. It corresponds to the secret key of $ \pk $ in the real protocol  in our instantiation of $ \Gen_{sign} $ (Algorithm \ref{alg:gensign}). Since an honest signature can be only generated by honest parties (showed below), even if $ x $ is a secret key, it does not help $ \simulator $ to generate forgeries in the ideal world.
	
\end{enumerate}
% The functionality lets parties generate a key (Key Generation), evaluate a message with the party's key (Ring VRF Evaluation), sign a message by one of the keys (Ring VRF signature) and verify the signature and obtain the evaluation output without knowing the key used for the signature and evaluation (Ring VRF Verification). 
%
%%We also define linking procedures in $ \fgvrf $ to link a signature with its associated key. So, if a party wants to reveal its identity at some point, it can use the linking process to show that the evaluation is executed with its key (Linking Signature). Later on, anyone can verify the linking signature (Linking Verification).
%
%In a nutshell, the functionality $\fgvrf$, when given as input a message $m$ and a key set $\ring$ (that we call a ring) of party, allows to create $n$ possible different outputs pseudo-random that appear independent from the inputs. The output can be verified to have been computed correctly by one of the participants in $\ring$ without revealing who they are. At a later stage, the author of the ring VRF output can prove that the output was generated by him and no other participant could have done so.
$ \fgvrf $  achieves the following properties:

\paragraph{Randomness:}  The evaluation of $ (\msg, \pk_i) $,  which is $ \evaluationslist[\msg,W] $ where $ \anonymouskeymap[\msg,W] = \pk_i $, is randomly selected independent from $ (\msg, \pk_i) $.

%Given that the evaluation of $  m, \pk  $ for any verification key $ \pk $ and for any message $ m $ has never been given to $ \simulator $, the probability that $ \simulator $ guesses the evaluation of $ m, \pk_i $ is $ \frac{1}{2^{\ell_\rvrf}} $, given that $  $

 Evaluation of $ (\msg, \pk_i) $ where $ \pk_i $ is an honest key is generated by first assigning a random anonymous key $ W $ to it and then assigning a random evaluation value $ y $ to $ (\msg, W)$. So, honest evaluations are always random and independent from $ (\msg,\pk_i) $. Malicious evaluation of $ (\msg, \pk_i) $, where $ \pk_i $ is not an honest key, is generated by first assigning an anonymous key $ W $ given by $ \simulator $ to it and then assigning a random value $ y $ to $ (\msg, W) $. Since $ \fgvrf $ checks whether $ W $ is unique, $ \fgvrf $ makes sure that evaluation of $ (\msg, \pk_i) $ is always random. If $ \fgvrf $ did not check this, then the evaluation of $ \msg, \pk_i $ would be the same as the evaluation of $ \msg, \pk_j  \neq \pk_i$ whose anonymous key is $ W $.





\paragraph{Determinism:} Once evaluation of $ (\msg, \pk_i) $, which is $ \evaluationslist[\msg,W] $ where $ \anonymouskeymap[\msg,W] = \pk_i $, is set, it cannot be changed. 

$ \fgvrf $ satisfies determinism because it checks whether $ (\msg, \pk_i) $ is evaluated before every time that it needs it. The only way for $ \simulator $ to change the evaluation of $ (\msg, \pk_i) $ is by changing the anonymous key of $ (\msg, \pk_i)  $ but the anonymous key cannot be changed similarly once it is set.

\paragraph{Unforgeability:}  If an honest party with a public key $ \pk $ never signs a message $ \msg $  with an associated data $ \aux $ for a ring $ \ring $, then no party can generate a  forgery of $ \msg $ with $ \aux $ for $ \ring $ signed by $ \pk $ i.e., there cannot be a record in $ \fgvrf $ such that $ [\msg, \aux,W,\ring, \sigma, 1] $ where $ \anonymouskeymap[\msg,\pk] = W $.

%We need verify that $ \sim $ cannot generate a signature $ \sigma $ that signs a message $ m $ for a ring $ \ring $ by an honest party's key $ \pk $. In other words, we need to verify that if $ \fgvrf $ never received a message $ (\oramsg{sign}, \sid,\ring,\pk,m) $ from an honest party $ \user $ with the key $ \pk $, $ \fgvrf $ cannot have a record $ [m, W, \ring, \sigma, 1] $ such that $ \anonymouskeymap[m,W]  = \pk$ (meaning that $ \sigma $ is a valid signature generated by the honest key $ \pk $). 
$ \sim $ cannot create a forgery by sending a message $ (\oramsg{sign}, \sid,\ring,\pk,\aux,\msg) $ to $ \fgvrf $ because $ \fgvrf $ checks whether the sender's key is $ \pk $ to generate a signature. Another way for $ \sim $ to create a forgery is by sending an honest key $ \pk_\simulator $  in C\ref{cond:malicioussignature} in Figure \ref{f:gvrf}. However, it is not allowed by $ \fgvrf $ in the condition C3-\ref{cond:forgery} neither.\eprint{ So, the only way that $ \fgvrf $ has a record $ [\msg, \aux,W,\ring, \sigma, 1] $ where $ \anonymouskeymap[\msg,\pk] = W $ is receiving a message $ (\oramsg{sign}, \sid,\ring,\pk,\aux,\msg)  $ from the honest party $\user  $ with key $ \pk $. Therefore, forgery is not possible in $ \fgvrf $.}{}

\paragraph{Uniqueness:} We call that an evaluation value $ y $ for a message $ \msg $  is verified for $ \ring $, if there exists a signature $ \sigma, W,\aux $ such that $ \fgvrf$ returns $ y, 1$ for a query $ (\oramsg{verify}, \sid, \ring,W,\aux,\msg,\sigma)$. The uniqueness property guarantees that the number of verified outputs via signatures for a message $ \msg $ and $ \ring $ is not more than $ |\ring| $.

We need to verify that number of outputs for a message $ \msg $ that are verified by  $ \ring $ is not greater than $ |\ring| $.
Assume that there exist $ t$ verified outputs $ \setsym{Y} = \{y_1, y_2, \ldots, y_t\} $ of a message $ \msg $. Therefore, for each $ y_i \in \setsym{Y} $, there exists a  record $ [\msg, \aux_i, W_i,\ring,\sigma_i,1] $ such that  $\evaluationslist[\msg,W_i] = y_i $ where $ \anonymouskeymap[\msg,W_i] = \pk_i $. If $ \pk_i $ is an honest verification key, it means that $ \sigma_i $ is not a forgery  thanks to the unforgeability property. Therefore, $ \pk_i \in \ring $. It means that honest evaluation values in $ \setsym{Y} $ cannot be more than $ |\ring \setminus \ring_{mal}| = n_h $. If $ \pk_i $ is not an honest verification key, $ W_i \in \anonymouskeylist[\msg,\ring] $ since $ \fgvrf $ adds $ W_i $ to $ \anonymouskeylist[\msg, \ring] $ whenever it creates such record for a malicious signature. $ \fgvrf $ makes sure that in the condition C3-\ref{cond:uniqueness} that $ \anonymouskeylist[\msg,\ring] \leq |\ring_{mal}| = n_m$. Therefore, $ t \leq n_h + n_m = |\ring| $.
%
% Clearly, in this case, $ W_i \neq W_j $ for all $ i \neq j $ since $ y_i \neq y_j $ by our assumption. The number of verified honest signatures in $ \setsym{S} $ cannot be more than number of honest verification keys in $ \ring $ because $ \fgvrf $ generates a signature for an honest party if the honest key is in the ring. Since each $ \msg,\pk $ is mapped to one unique evaluation value,
%
%Also, it generates a unique anonymous key for each pair $ \msg,\pk $. So, if an honest signature for $ \msg,\ring $ is verified it means that the honest verification key $ \pk $ is in $ \ring $ and $ (\msg,\pk) $ has a unique anonymous key so that unique evaluation output. Therefore, the number of anonymous keys (so that evaluation outputs) for the honest signatures is at most number of honest keys in $ \ring $. Since we know that once anonymous key $ W_i $ is set for $ m, \pk_i $, it cannot be changed. This means that there exist at least $ |\ring_{mal}| + 1 $ signatures in $ \setsym{S} $. When $ \fgvrf $ verifies a malicious signature, it checks in the condition C3-\ref{cond:uniqueness} how many malicious anonymous keys generated for malicious signatures of $ m, \ring $ so far. If it is more that $ |\ring_{mal}| $, $ \fgvrf $ does not verify it so that it does not output an evaluation value during such signature verification. Therefore, the simulator can generate at most $ |\ring_{mal}| $ anonymous keys for verified signatures for $ \ring $. This implies that the number of verified outputs of malicious parties   is $ |\ring_{mal}| $. 

\eprint{\paragraph{Robustness:} $ \simulator $ cannot prevent an honest party to evaluate, sign or verify.
The only place that $ \fgvrf $ does not respond any query is when it aborts. It happens when it selects an honest anonymous key which already existed. This happens in negligible probability in $ \secparam $. }{}


\paragraph{Anonymity:} An honest signature $ \sigma $ of a message $ \msg $ verified by a ring and anonymous key $ W $ does not give any information about its signer except that its key is in $ \pk $ if $ \msg $ is not signed before for any other ring. We define this formally with the anonymity game below. We note that we cannot define and verify this property in $ \fgvrf $ as the other properties because it depends on how $ \Gen_{sign} $ is defined.

\begin{definition}[Anonymity]\label{def:anonymity}
	$ \fgvrf $ satisfies anonymity, if any PPT distinguisher $ \mathcal{D} $ has a negligible advantage in $ \secparam $ to win the anonymity game defined as follows:
	We define the anonymity game between a challenger and $ \mathcal{D} $.  $\mathcal{D}$ accesses a signing oracle $ \mathcal{O}_{Sign} $ and $ \fgvrf $ simulated by the challenger as described in Figure \ref{f:gvrf}. 
	\begin{itemize}
		\item Given the input $ '\mathsf{keygen}' $, $\mathcal{O}_{Sign} $ sends $ (\oramsg{keygen, \sid}) $ to the challenger and obtains a verification key $ \pk $. Then, it stores $ \pk  $ to a list $ \mathcal{K} $ and outputs $ X,\pk $.
		\item Given the input $ '(\pk,\ring,\aux,\msg)' $, $ \mathcal{O}_{Sign} $ sends $ (\oramsg{sign}, \sid,\ring,\pk, \aux, \msg) $ to the challenger and receives $ (\oramsg{signature}, \sid, \ring, W,\aux, \msg, y, \sigma) $ if $ \pk \in \ring $.  Then $ \mathcal{O}_{Sign} $ stores $ \msg $ to a list $ \arraysym{signed}[\pk]  $.
		% and $ W  $ to a list $ \anonymouskeylist $. 
		It outputs $ (\sigma,W) $. Otherwise, it outputs $ \perp $.
	\end{itemize}
	At some point,	
	$ \mathcal{D} $ sends $ (\ring, \pk_0, \pk_1, \msg,\aux)$ to  the challenger where $ \pk_0, \pk_1 \in \ring $, $ \msg  \notin \arraysym{signed}[\pk_0]$ and $ \msg  \notin \arraysym{signed}[\pk_1] $.  Challenger lets $ b \leftarrow_r\bin$. Then it gives the input $ (\pk_b, \ring, \msg,\aux) $ to $ \ora{Sign} $ and receives either $ \perp $ or $(\sigma,W)$. If it is $ (\sigma,W) $, it sends $ (\sigma,W) $ to $ \mathcal{D} $ as a challenge.
	If $ \mathcal{D} $ sends $ '(\pk,\ring,\aux,\msg)' $ to $ \mathcal{O}_{Sign} $ where $ \pk = \pk_0 $ or $ \pk = \pk_1 $, it loses the game. 
	During the game if $ \mathcal{D} $ outputs $ b' = b $, $ \mathcal{D} $ wins.
	
	
\end{definition}






%
%to make $ \fgvrf $ set $ \anonymouskeymap[m,W] $ with an honest key for any $ m,W $.  Let's see whether this is possible. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature.

%
% to generate a valid signature is via verification i.e., when a party sends a message  $ (\oramsg{verify}, \sid,\ring,W,m, \sigma) $ to $ \fgvrf $.  During the verification, if $ \fgvrf $ is in \ref{cond:differentsignature} and \ref{cond:simulatorbit} then the validity of the signature is decided by $ \simulator $. If $ \fgvrf $ is in \ref{cond:simulatorbit}, it means that there exists no $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H $ because if it existed, $ \fgvrf $ would be in \ref{cond:differentsignature}. Therefore, the signature verified in \ref{cond:simulatorbit} cannot be a signature of an honest party's key.  This means that $ \simulator $ cannot generate a forgery via \ref{cond:simulatorbit}. So, the only left way for $ \simulator $ to generate a forgery is via \ref{cond:differentsignature}.
%If $ \fgvrf $ is in \ref{cond:differentsignature}, then $ \anonymouskeymap[m,W] $ belongs to an honest party and another signature $ \sigma' \neq \sigma $ has already been stored as valid for $ W, \ring, m $.  If $ \sigma' $ is not generated by this honest party, then it means that $ \simulator $ forges. Let's see whether this is possible. If there exists a record $ [m, W, \ring, \sigma',1] $ , it means that $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H$ exists. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature via \ref{cond:differentsignature}.



%Now, we verify that $ \fgvrf $ satisfies these properties. During our analysis, when we say that a message $ m $ signed by an anonymous key $ W $ we mean that $ [m,W,.,.,1] $ is recorded. We say that the signature is honest if $ \anonymouskeymap[m,W] = \pk $ is an honest party's key.
%
%
%
%\paragraph{\textbf{Uniqueness:}}
%
%\paragraph{\textbf{Robustness:}} We check whether $ \simulator$ can prevent an honest party signing and verifying. $ \fgvrf $ does not abort during the verification so an honest party can verify all signatures. $ \fgvrf $ aborts during the honest signing process if $ \gen_{sign}(m, \ring) $ generates a signature which was invalidated before i.e., there exists a record $ [m, W, \ring, \sigma,0] $.
%
%
%
%
%\begin{enumerate}[label={{R-} }{{\arabic*}}, start = 1]
%
%%\item The ring VRF signature does not need to be random but it must be \emph{unique}  for its ring and the message. The reason of it to have a mapping from a ring VRF signature to its evaluation output. The map is necessary for $ \fgvrf $ to output the corresponding evaluation value for the signature during the verification process i.e, $ [m, \ring, \sigma] \rightarrow \pk, \evaluationsecretlist[m, \ring][\pk] \rightarrow y $.
%\item In classical VRF, a VRF $ F $ is a deterministic function which maps a message and a public key to a random output. While in ring VRF, a message, a public key and a ring map to a random value, the verification algorithm of a ring VRF does not take the key as an input because it should be hidden. Therefore, the verification should be executed without the public key.  So, the functionality $ \fgvrf $ needs to find a way to verify the ring VRF output of a message, a public key and a ring map without knowing the public key. Because of this, $ \fgvrf $ generates an anonymized key $ W $ for each evaluation so that a message $ m $  and $ W $ maps to the random output. One can imagine this  as if a VRF output is generated with the input message $ m $ and the key $ W $ as in classical VRF i.e.,  $ F(m, W) $. 
%
%\item  If an honest party signs a message for a ring and obtains a signature, $ \fgvrf $ allows the simulator to generate another signature in \ref{cond:differentsignature} if the simulator wants. We remark that this is not a security issue because an honest party has already committed to sign the message.  A similar condition  exists in the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.
%
%\item \ref{cond:simulatorbit} of the ring VRF verification process covers the case where the adversary decides whether accepting the signature generated for its key if  it could be a valid signature for the ring i.e., the malicious key is in the ring and the anonymous key in the verification request is unique.
%
%\item The linking signature and the linking verification works similar to the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.


%\end{enumerate}


%\begin{definition}[Anonymous $ \fgvrf $]\label{def:anonymity}
%	We call that $ \fgvrf $ is anonymous if the outputs of $ \gen_{sign} $ and $ \gen_W $ are pseudo-random.
%	%TODO define this more formally.
%\end{definition}


%
%Below, we define the real-world execution of a ring VRF.
%\begin{definition}[Ring-VRF (rVRF)]\label{def:ringvrf}
%	%TODO ADD anonymous key here
%	A ring VRF is a VRF with a  function $ F(.):\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $ and with the following algorithms:
%	
%	\begin{itemize}
	%		\item $ \rvrf.\keygen(1^\kappa) \rightarrow (\skrvrf,\pk)$ where $ \kappa $ is the security parameter,
	%	\end{itemize}
%	Given list of public keys $ \ring = \set{\pk_1, \pk_2, \ldots, \pk_n}$, a message $ m \in \{0,1\}^{\ell_m} $
%	\begin{itemize}
	%		\item $ \rvrf.\eval(\skrvrf_i, \ring, m) \rightarrow y$
	%		\item $ \rvrf.\sign(\skrvrf_i, \ring, m)\rightarrow (\sigma,W) $ where  $\sigma $ is a signature of the message $ m $ signed by $ \skrvrf_i, \ring $ and $ W $ is an anonymous key.
	%		\item $ \rvrf.\verify(\ring,W, m,\sigma) \rightarrow  (b, y)$ where $ b \in \{0,1\} $ and $ y \in \{0,1\}^{\ell_\rvrf}\cup \{\perp\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
	%%		\item $ \rvrf.\link(\skrvrf_i, \ring,W,m, \sigma) \rightarrow \hat\sigma $ where  $ \hat\sigma $ is a signature that links signer of the ring signature $ \sigma $. 
	%%		\item $ \rvrf.\link\verify( \pk_i,\ring,W, m, \sigma, \hat\sigma)\rightarrow b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
	%	\end{itemize}
%	
%\end{definition}
