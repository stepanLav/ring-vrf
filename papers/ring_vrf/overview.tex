\section{An Overview on Ring VRFs}
\label{sec:overview}

As a beginning, we introduce the ring VRF interface, give a simple
unamortized non-interactive zero-knowledge (NIZK) protocol that realizes the ring VRF properties discussed formally in \S\ref{subsec:uc_mode},
and give some intuition for our later amortization trick. 


As VRF \cite{vrf_micali}, a ring VRF needs a \KeyGen algorithm and an $ \Eval $ algorithm,

\begin{itemize}
	\item $ \rVRF.\KeyGen: (\secparam) \mapsto (\sk, \pk) $  returns a secret key \sk and
	associated public key \pk given the security parameter $ \secparam $.
	\item $\rVRF.\Eval : (\sk,\msg) \mapsto \Out$ returns an evaluation output $ \Out $ given secret key $ \sk $ and a message $ \msg $.
\end{itemize}
The security properties that we expect from $ \KeyGen $ and $ \Eval $ in a ring VRF are similar to VRF i.e., $ \Eval $ is a deterministic algorithm and $ \Out $ is pseudorandom \cite{praos,ucvrf}.
 % for which many constructions exist.
%

% In other words,
% internally we prove a VUF output $\PreOut = \sk H_{\grE}(\msg)$,
% with a hash-to-curve $H_{\grE}$, so then applying a PRF $H'$ yields a
% VRF output $\Out = H'(\msg, h \PreOut)$ ala \cite[Prop. 1]{vrf_micali},
% using a key pair like $\pk = \sk \genG$ for a generator $\genG$.

%At their simplest, ring VRFs' algorithms could operate directly
%upon the signer set \ring:
Differently than VRF, a ring VRF has the following algorithms which operate directly
upon the signer set \ring:
\begin{itemize}
\item $\rVRF.\rSign : (\sk,\ring,\msg) \mapsto \sigma$ \,
    returns a ring VRF signature $\sigma$ for an input \msg.
\item $\rVRF.\rVerify : (\ring,\msg,\sigma) \mapsto \Out \, \lor \perp$ \,
    returns either an output $\Out$ or else failure $\perp$.
\end{itemize}

The most critical difference of a ring VRF from a VRF is that the verification does not require the public key of the signer to verify the signature and to output the evaluation value generated by $ \rVRF.\Eval $. Therefore, the algorithm $ \rVRF.\Verify $ of a correct and secure ring VRF protocol should verify the following relation with a signature $ \sigma $ intuitively:  


$$ \Setst{ ((\sk, \pk),(\Out, \msg, \ring))}{
    \eprint{
        (\pk,\sk) \leftarrow \rVRF.\KeyGen(\secparam), \quad %   \textrm{ and }
        \pk \in \ring, \quad
        \Out = \rVRF.\Eval(\sk,\msg)
    }{
        \begin{aligned}
        & (\pk,\sk) \leftarrow \KeyGen(\secparam) \\
        & \pk \in \ring \\
        & \Out = \rVRF.\Eval(\sk,\msg)
        \end{aligned}
    }
} $$

So, while a verifier verifies a signature $ \sigma $ of a message $ \msg $ with a set of public key $ \ring $, she should be convinced that $ \Out $ is generated for the input $ \msg $ with a secret key $ \sk $ of which the  public key $ \pk $ is in the set  $ \ring $. 

The reason of having the verification without the signer's public key is that we would like to have an anonymity property in ring VRF meaning that a verified signature and evaluation output do not leak any information except that the signer's public key is in $ \ring $.
This property can be achieved with a NIZK protocol for the relation above where $ (\sk,\pk) $ is the witness. However, there are smarter ways to achieve it instead of directly use a NIZK protocol that proves the relation above. Therefore, we design a protocol that achieves the security properties that we aim for with two efficient NIZK protocols: Chaum-Pedersen discrete logarithm equality (DLEQ) NIZK and  a our nobel zkSNARK technique (See \S\ref{sec:rvrf_cont}) built from
rerandomizable Groth16s \cite{Groth16} and designed for composition and reuse.




%We would need time $O(|\ring|)$ in \rSign and \rVerify merely to read
%this \ring argument.  Instead, ring signatures run asymptotically faster
%by replacing the \ring argument with some set commitment to \ring,
%roughly like what ZCash does.
%\begin{itemize}
%% \item $\rVRF.\CheckRing : \ring \mapsto \comring$ takes a set \ring of public keys and returns a public key set commitment \comring.
%\item $\rVRF.\CommitRing : (\ring,\pk) \mapsto (\comring,\openring)$ \,
%    returns a commitment for a set \ring of public keys, and
%    optionally the opening \openring for some $\pk \in \ring$ as well.
%\item $\rVRF.\OpenRing : (\comring,\openring) \mapsto \pk \, \lor \perp$ \,
%    returns a public key \pk, provided \openring correctly opens
%    the ring commitment \comring, or failure $\perp$ otherwise.
%\end{itemize}
%
%We thus replace the membership condition $\pk \in \ring$ in the above
%relation and NIZK by the by the opening condition
%$$ \exists \openring \textrm{\ s.t.\ } \pk = \OpenRing(\comring,\openring) \mathperiod $$
%% $\pk = \OpenRing(\comring,\openring)$.
%%
%% $$ \pi_0 = \NIZK \Setst{ \Out, \msg, \comring }{
%%     \begin{aligned}
%%         (\pk,\sk) &\leftarrow \KeyGen,  \quad
%%           \Out = \PRF(\sk,\msg)  \\
%%         \exists \openring \textrm{\ s.t.\ }
%%           \pk &= \OpenRing(\comring,\openring)  \\      
%%     \end{aligned}
%% } $$
%
%
%Aside from proving a PRF evaluation, an EC VRF should typically sign
%some auxiliary data \aux by hashing \aux when computing its challenge,
%but doing so only saves one redundant signature verification for EC VRF.
%Auxiliary data becomes critical for ring VRFs, because otherwise
%unmoored ring VRFs invariably permit replay attacks.
%As an example, if ring VRFs authorized creating blocks in an anonymous
%praos \cite{praos} blockchain then \aux must include the block being
%created, or else others could steal the block production turn.%
%\footnote{We suppress multiple input-output pairs until \S\ref{subsec:multi_io} below, but they work like in \cite{PrivacyPass}.}
%
%Our algorithms for a {\em ring verifiable random function with auxiliary data} (rVRF-AD) therefore look like
%\begin{itemize}
%\item $\rVRF.\rSign : (\sk,\openring,\msg,\aux) \mapsto \sigma$, \quad and
%\item $\rVRF.\rVerify : (\comring,\msg,\aux,\sigma) \mapsto \Out \,\, \lor \perp$.
%\end{itemize}
%
%Although asymptotically faster, our opening \OpenRing invariably
%winds up being extremely heavy inside a zkSNARK.
%We solve this obstacle in \S\ref{sec:rvrf_cont} below by introducing
%{\em zero-knowledge continuations}, a new zkSNARK technique built from
%rerandomizable Groth16s \cite{Groth16} and designed for composition and reuse.
%
%In this, we should split the relation describing our ring VRF into
%a VRF evaluation relation \Leval and a reusable or continuable relation
%\Lring, which enforces our heavy $\pk = \OpenRing(\comring,\openring)$
%condition.  Anonymity requires we rerandomize a Groth16 SNARK for \Lring
%ala \cite[Theorem 3, Appendix C, pp. 31]{RandomizationGroth16}.
%%
%Yet, we must join aka pass \pk from \Lring to \Leval somehow, which
%demands some hiding commitment \compk of course.
%%
%\def\tmpAA{\textrm{\compk commits to\ }}
%\def\tmpBB{\OpenRing(\comring,\openring)}
%$$ \Lring = \Setst{ \compk, \comring }{
%	\eprint{
%	\tmpAA \pk = \tmpBB
%	}{
%    \begin{aligned}
%	&\tmpAA \\
%	&\, \tmpBB \\
%    \end{aligned}
%	}
%} $$
%
%We discovered this becomes incredibly efficient if one specializes
%the Groth16 construction:  An inner true Groth16 for $\Lring'$ handles
%the secret key \sk directly, while our Pedersen commitment \compk is
%built outside this Groth16.
%$$ \Lring' = \Setst{ \sk, \comring}{
%    \eprint{
%    (\pk,\sk) \leftarrow \KeyGen, \quad % \textrm{ and }
%    \pk = \OpenRing(\comring,\openring) 
%    }{
%    \begin{aligned}
%        &(\pk,\sk) \leftarrow \KeyGen, \\
%        % \exists \openring \textrm{\ s.t.\ }
%        &\pk = \OpenRing(\comring,\openring)  \\      
%    \end{aligned}
%    }
%} $$
%
%$$ \Leval = \Setst{ \Out, \msg, \aux, \compk }{
%    \begin{aligned}
%	&\Out = \PRF(\sk,\msg), \\
%	&\textrm{\compk commits to\ \sk} \\
%    \end{aligned}
%} $$
%
%In \S\ref{sec:rvrf_cont} we rerandomize $\compk = \pk + b \, K$
%without reproving the Groth16 for \Lring, but instead requires
%expanding the Groth16 trusted setup into what becomes zero-knowledge continuation.
%%
%In \S\ref{sec:pederson_vrf}, we introduce an extremely efficient NIZK
%for \Leval, which also provides an essential proof-of-knowledge for \compk.
%
%
%\endinput
%
%
%
%
%
%% We define ring VRFs in \S\ref{sec:rvrf_games} and \S\ref{sec:rvrf_uc_fun} below, but
%Ring VRFs are firstly ring signatures broadly interpreted, in that they
%prove an involved public key lies inside some commitment \comring to
%the plausible signer set, known as the ring.
%Anyone could compute \comring from this set of public keys.
%%
%At the same time, ring VRFs prove correct output of a PRF keyed by
%the signer's actual secret key, and evaluated on a supplied message \msg,
%which then links ring VRF signatures on the same \msg.
%
%\smallskip
