\newcommand{\name}{rVRF}
\section{Security of Our Ring VRF Construction} 
\label{ap:ucproof}
\label{sec:ringvrfconstrnoPK}
\newcommand{\GG}{\grE}
\newcommand{\FF}{\F}
\newcommand{\hash}{H}
\newcommand{\hashG}{\hash_\grE}
\newcommand{\gen}{\mathsf{Gen}}
\newcommand{\hkeys}{\mathtt{h\_keys}}
\newcommand{\malkeys}{\mathtt{m\_keys}}
\newcommand{\rcom}{\mathcal{R}_{eval}}
\newcommand{\rsnark}{\Rring}
\newcommand{\counter}{\mathsf{counter}}
\newcommand{\bdv}{\mathcal{B}}
\newcommand{\abort}{\textsc{Abort}}
\newcommand{\pkeys}{\arraysym{public\_keys}}
\newcommand{\skeys}{\arraysym{secret\_keys}}
\newcommand{\keytransform}{T_{\mathsf{key}}}
%Before giving the security proof of our protocol, we give the protocol in Section \ref{sec:pederson_vrf} without the abstraction from $ \PedVRF $ for the sake of  clarity of the security proof.
%
%We instantiate parameter generation by constructing a group $\GG$ of order $ p $ and two generators $ \genG, \genB \in  \GG$.  We consider three hash functions: $ \hash, \hash_p: \{0,1\}^* \rightarrow \FF_p $ and a hash-to-group function $\hashG : \{0,1\}^* \rightarrow \GG$ and . \name \ works as follows:
%
%\begin{itemize}
%	\item $ \rVRF.\KeyGen(1^\kappa):  $ It selects randomly a secret key $ x \in \FF_p$ and computes the public key $ X = xG $. In the end, it outputs $ \sk = x $ and $ \pk = X $.
%	
%	%It also generates  PoK for the discrete logarithm of $ X $ for the relation $ \R_{dl} $, $ \NIZK.\Prove(\rdl, (x, (X, G, \GG))) \rightarrow \pi_{dl} $.
%	
%	%\begin{equation}
%	%	\rdl = \{(x,(X,G,\GG)): X,G \in \GG, x \in \FF_p, x = xG\}
%	%\end{equation}
%	
%	%For this, it does the following: $ a \leftsample \FF_p $, $ c = \hash_p(a\genG, X) $, $ s = a + cx $. 
%	
%	%	\item $ \rVRF.\eval(\sk, \ring, m) $: It lets $ P = \hashG(m, \ring) $ and computes $ W = xP  $. Then, it outputs $ y = \hash(m, \ring, W) $. So, the deterministic function $ F $ in our rVRF protocol is $ F(\sk, \ring, m) = H(m, \ring, x\hashG(m,\ring)) $.
%	%	
%	\item $ \rVRF.\Sign(\sk, \ring, m):$ It lets $ \In = \hashG(m) $ and computes the pre-output $ \PreOut= x\In$. The signing algorithm works as follows: 
%
%	\begin{itemize}
%		
%		\item It first commits to its secret key $
%		x$ i.e., $ \compk = X + \openpk \, \genB $ where $ \openpk \leftsample \FF_p $.
%		\item It generates a Chaum-Pedersen DLEQ proof $ \pi_{eval} $ showing the following relation by running the algorithm $ \NIZK_{\rcom}.\Prove(((\genG, \genB,\GG,\compk,\PreOut,\In); (x, \openpk))) $ which outputs $ \rightarrow \pi_{eval}$
%		\eprint{\begin{align}
%				\rcom= \{((x, \openpk), (\genG, \genB,\GG,\compk,\PreOut,\In)): 
%				\compk = x\genG + \openpk\, \genB, \PreOut = x \,\In \} \label{rel:commit} 
%		\end{align}}{
%		\begin{align}
%			\rcom= \{((x, \openpk), (\genG, \genB,\GG,\compk,\PreOut,\In)): \\
%			\compk = x\genG + \openpk\, \genB, \PreOut = x \,\In \} \label{rel:commit} \nonumber
%		\end{align}}
%		Here $ \Prove $ algorithm runs a non-interactive Chaum-Pedersen DLEQ proof with the Fiat-Shamir transform:  Sample random $r_1, r_2 \leftarrow \F_p$.
%		Let $R = r_1 \genG + r_2 K$, $R_m = r_1 \In$, and
%		$c = \hash_p(\ring, m, \PreOut,\compk,R,R_m)$.
%		Set $\pi_{eval} = (c,s_1,s_2)$ where $s_1 = r_1 + c x$ and $s_2= r_2 + c \, \openpk$.
%		\item %It obtains $ crs $ from $ \gcrs $ for the second proof by sending the message $ (\oramsg{learncrs}, \sid) $ to $ \gcrs $. Then,
%		%It constructs a Merkle tree $ \mathsf{MT} $ with the nodes $ X_i $ where  $ X_i \in \pk_i $ and $ \pk_i \in  \ring $. We denote its  root by $ \mathsf{root} $. In the end, 
%		It generates the second proof $ \pi_{ring} $ for the following relation with  the witness $ (\ring, x, \openpk) $. 		
%		
%		\eprint{\begin{equation}
%				%\rsnark = \{((\mathsf{copath}, X, \openpk),(G,\genB\GG,\mathsf{root}, \compk)): C-\openpk K = X, \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) \rightarrow 1\} \label{rel:snark}
%				\rsnark = \{(X, \openpk),(\genG,\genB,\GG,\ring, \compk)): \compk-\openpk \, \genB = X \in \ring\} \label{rel:snark}
%			\end{equation}
%		}{\begin{align}
%			\rsnark = \{(X, \openpk),(\genG,\genB,\GG,\ring, \compk)): \\\compk-\openpk \, \genB = X \in \ring\} \label{rel:snark} \nonumber
%		\end{align}
%	}
%		
%		%Here, $ \mathsf{copath} $ is a copath of the Merkle tree $ \mathsf{MT} $. $ \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) $ is a verification algorithm of the Merkle tree which verifies whether $ X $ is the one of the leaves of $ \mathsf{MT} $ i.e., compute a root $ \mathsf{root}' $ with $ X $ and $ \mathsf{copath} $ and output 1 if $ \mathsf{root} = \mathsf{root}' $.
%		
%		The second proof $ \pi_{ring} $ is generated by running 
%		$ \NIZK_{\rsnark}.\Prove(((\genG,\genB,\GG,\ring, \compk); (X, \openpk))) $ 
%	\end{itemize}
%	In the end, $ \rVRF.\Sign $ outputs $\sigma = (\pi_{eval}, \pi_{ring}, \compk, \PreOut) $.
%	
%	\item $ \rVRF.\Verify(\ring,\PreOut, m, \sigma) $: Given $  \sigma = (\pi_{eval}, \pi_{ring},\compk)  $ and $ \ring, \PreOut $,
%	% it first runs $ \NIZK.\Verify(\rdl,(X_i,\genG,\GG), \pi_{dl_i}) $ for each $ \pk_i= (X_i, \pi_{dl_i})  \in \ring $. If each of key in $ \ring $ verifies,
%	it runs $ \NIZK_{\rcom}.\Verify((\genG, \genB,\GG,\compk,\PreOut,\In), \pi_{eval} ) $ where $ P = \hashG(m) $. $ \NIZK_{\rcom}.\Verify $ works as follows: $ \pi_{eval} = (c,s_1, s_2) $, it lets $R' = s_1 \genG + s_2 \, \genB - c \,\compk$ and $R'_m = s_1 \hashG(m) - c \, \PreOut$. It
%	returns true if $c = \hash_p(\ring,m,\PreOut,\compk,R',R'_m)$. If  $ \NIZK_{\rcom}.\Verify((\genG, \genB,\GG,\compk,\PreOut,\In), \pi_{eval} ) $ outputs 1, it runs $ \NIZK_{\rsnark}.\Verify((\genG,\genB,\GG,\ring, \compk), \pi_{ring}) $. 
%	If all verification algorithms verify, it outputs $ 1 $ and the evaluation value $ y =  \hash(m,\PreOut)  $. Otherwise, it outputs $( 0, \perp) $.
%	
%\end{itemize}
%
%\subsection{Security Analysis}

Before we start to analyse our protocol, we should define the algorithm $ \gen_{sign} $  for $ \fgvrf $ and show that $ \fvrf $ with $ \gen_{sign} $ satisfies the anonymity defined in Definition \ref{def:anonymity}. $ \fgvrf $ that \name \ realizes runs  Algorithm \ref{alg:gensign} to generate honest signatures.



%\begin{algorithm}
%	\caption{$\gen_{W}(\ring,\pk,m)$}
%	\label{alg:genW}	 	
%	\begin{algorithmic}[1]
	%		\State$ W \leftsample\GG $
	%		%		\State \textbf{get} $ X \in \pk $
	%		%		\If{$\mathtt{DB}[m, \ring] = \perp  $}		
	%		%		\State{$ a \leftsample \FF_p $}		
	%		%		\State{$\mathtt{DB}[m, \ring] := a$}
	%		%		\EndIf
	%		%		\State$ a \leftarrow \mathtt{DB}[m, \ring] $
	%		%		
	%		%		\State \textbf{return} $ aX $
	%		\State \textbf{return} $ W $
	%	\end{algorithmic}
%	
%\end{algorithm}

\begin{algorithm}
	
	\caption{$\gen_{sign}(\ring,W,\{X,\pk\},\aux,\msg)$}
	\label{alg:gensign}	 	
	\begin{algorithmic}[1]
		\State $ c,s_1, s_2 \leftsample \FF_p $
		\State $ \pi_{eval}  \leftarrow (c,s_1, s_2)$
		\State $ \openpk \leftsample \FF_p $
		\State $ \compk =  x \genG + \openpk \, K$
		%\State $ \pi_{eval} \leftarrow \NIZK.\mathsf{Simulate}(\rcom, (G, \genB,\GG,\compk,W,\In)) $
		%\State \textbf{send} $(\oramsg{learn\_\tau},\sid)  $ to $ \gcrs $
		%\State \textbf{receive} $(\oramsg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
		\State $ \comring, \openring \leftarrow \rVRF.\CommitRing(\ring, \pk) $
		\State $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\Prove((\comring, \compk); (\openpk, \openring)) $ 
		\State\Return$ \sigma = (\pi_{eval},\pi_{ring},\compk,\comring,W) $
	\end{algorithmic}
	
\end{algorithm}


\begin{lemma} \label{lem:anonymity} $ \fgvrf $ running Algorithm \ref{alg:gensign} satisfies anonymity defined in Definition \ref{def:anonymity} assuming that $ \NIZK_{\rsnark} $ is a zero-knowledge and Pedersen commitment is perfectly hiding.
\end{lemma}

\begin{proof}
	We simulate $ \fgvrf $ with Algorithm \ref{alg:gensign} against $ \mathcal{D} $. Assume that the advantage of $ \mathcal{D} $ is $ \epsilon $. We reduce the anonymity game to the following game where we change the simulation of $ \fgvrf $ by changing the Algorithm \ref{alg:gensign}. In our change, we let $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\mathsf{Simulate}(\genG,\genB,\GG,\comring, \compk) $. Since $ \NIZK_{\rsnark} $ is zero knowledge, there exists an algorithm  $ \NIZK_{\rsnark}.\mathsf{Simulate} $ which generates a proof which is indistinguishable from the proof generated from $ \NIZK_{\rsnark}.\Prove $. Therefore, our reduced game is indistinguishable from the anonymity game. Since in this game, no public key is used while generating the proof and $ W $ and $ \compk $ is perfectly hiding, the probability that  $ \mathcal{D} $ wins the game is $ \frac{1}{2} $. This means that $ \epsilon $ is negligible.		
\end{proof}

%We next show that \name \ realizes $ \fgvrf $  in the random oracle model under the assumption of the hardness of the decisional Diffie Hellman (DDH).

%The GDH problem is solving the computational DH problem by accessing the Diffie-Hellman oracle ($ \mathsf{DH}(.,.,.) $) which tells that given triple $ X,Y,Z $ is a DH-triple i.e., $ Z = xyG $ where $ X = xG $ and $ Y = yG $.

%\begin{definition}[$ n $-One-More Gap Diffie-Hellman (OM-GDH) problem]
%	Given   $ p $-order group $ \GG $ generated by $ G $, the challenges $ G, X = xG, P_1, P_2, \ldots, P_{n+1} $ and access to the DH oracle $ \mathsf{DH}(.,.,.) $ and the oracle $ \mathcal{O}_x(.) $ which returns $ x\In$ given input $ \In$, if a PPT adversary $ \mathcal{A} $ outputs $ xP_1, xP_2, \ldots, xP_{n+1} $ with the access of at most $ n $-times to the oracle $ \mathcal{O}_x $, then $ \mathcal{A}  $ solves the $ n $-OM-GDH problem. We say that $ n $-OM-GDH problem is hard in $ \GG $, if for all PPT adversaries, the probability of solving the $ n $-OM-GDH problem is negligible in terms of the security parameter.
%\end{definition}

\begin{theorem}
	Assuming that $ \hashG, \hash,\hash_p, \hash_\ring $ are random oracles,  the DDH problem is hard in the group structure $ (\GG, \genG,\genB, p) $, NIZK algorithms are zero-knowledge and knowledge sound and the commitment scheme is perfectly hiding and computationally binding, \name \ UC-realizes $\fgvrf$ running Algorithm \ref{alg:gensign}.
\end{theorem}

\begin{proof}
	We construct a simulator $ \simulator $ that simulates the honest parties in the execution of \name \ and simulates the adversary in $ \fgvrf $. 
	
		%\item \textbf{[Simulation of $ \gcrs $:] }When simulating $ \gcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rsnark) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $. Whenever a party comes to learn the $ crs $, $ \simulator $ gives $ crs $ as  $ \gcrs $.
		
		 \noindent\textbf{[Simulation of $ \oramsg{keygen} $:]} Upon receiving $(\oramsg{keygen}, \sid, \user_i)$ from $\fgvrf$, $ \simulator $ obtains the a secret and public key pair $ x = (\sk,r)$ and $\pk $ by running $ \rVRF.\KeyGen $. It adds $ \pk $ to lists $ \hkeys $ and $ \vklist $ as a key of $ \user_i $. 
		 $ \simulator $ returns $(\oramsg{verificationkey}, \sid, x,\pk)$ to $\fgvrf$. 
		$ \simulator $ lets  $ \pkeys[X] = \pk$ and $ \skeys[X] =(\sk,r) $ where $ X = \sk \genG $.
		%Whenever the honest party $ \user $ is corrupted by $ \env, $ $ \simulator $ moves the key of $ \user $ to $ \malkeys $ from $ \hkeys $.
		
		 \noindent\textbf{[Simulation of corruption:]} Upon receiving a message $ (\oramsg{corrupted}, \sid, \user_i) $ from $ \fgvrf $, $ \simulator $ removes the public key $ \pk $ from $ \hkeys $ which is stored as a key of $ \user_i $ and adds $ \pk $ to $ \malkeys $.
		
		\noindent\textbf{[Simulation of the random oracles:]} We  describe how $ \simulator $ simulates the random oracles $ \hashG, \hash, \hash_p $ against the real world adversaries. 	
		
		$ \simulator $ simulates the random oracle $ \hashG $ as described in Figure \ref{oracle:HgnoPK}. \eprint{It selects a random element  $ h $ from $ \FF_p $ for each new input and outputs $ hG $ as an output of the random oracle $ \hashG $.}{} Thus, $ \simulator $ knows \emph{the discrete logarithm of each random oracle output of $\hashG  $}. 
		 The simulation of the random oracle $ \hash $ is less straightforward (See Figure \ref{oracle:HnoPK}).
		The value $ W $ can be a pre-output generated by $ \rVRF.\Eval $ or can be an anonymous key of  $ m $ generated by $ \fgvrf $ for an honest party. $ \simulator $ does not need to know about this at this point but $ \hash $ should output $ \evaluationslist[m,W] $ in both cases.	 
		%If $ W $ is a pre-output, $ \simulator $ needs to find corresponding malicious public key in the real world. If it is the case, $ W $ should be equal to $ x\hashG(m, \ring)= xhG $  where $ xG $ is a public key. 
		\eprint{	$ \simulator $ pretends $ W $ as if it is a pre-output. So, $ \simulator $ first obtains the discrete logarithm $ h $ of $ \hashG(m) $ from the $ \hashG $'s database and finds out a commitment key $ X^* = h^{-1}W $.}{}
		%If $ X^* $ has not been registered as a malicious key, it registers it to $ \fgvrf $. Thus, $ \simulator $ has a right to ask the output of the message $ m, \ring $ to $ \fgvrf $. 
	\eprint{	If  $ \skeys[X^*] $ is not empty, it replies by a randomly selected value from $ \FF_p $.
		Otherwise,
		$ \simulator $ checks if $ \pkeys[X^*] $ exists to see whether a corresponding public key of $ X^* $ exists. If it does not exist, $ \simulator $ picks a key $ \pk^* $ which is not stored in $ \pkeys $ and stores $ \pkeys[X^*] = \pk^* $. In any case, it obtains $ \evaluationslist[m,W] $ by sending a message $ (\oramsg{eval}, \sid,\pk^*,W,m) $ and replies with $ \evaluationslist[m,W] $.}{}
		Remark that in $ \hash $ if $ W $ is a pre-output generated by $ \adv $,  $ \fgvrf $ matches it with the evaluation value given by $ \fgvrf $. If $ W $ is an anonymous key of an honest party in the ideal world, $ \fgvrf $ still returns an honest evaluation value $ \evaluationslist[m,W] $ even if $ \simulator $ cannot know whether $ W $ is an anonymous key of an honest party in the ideal world. 
		% Remember that $ \fgvrf $ only replies to the evaluation message of $ \simulator $ if $ W $ is not mapped to another message, ring and public key $ (m', \ring', X')   $. $ W $ cannot be map to $ (m', \ring', X')   \neq  (m, \ring, X*)   $ because it would be aborted during the simulation $ \hashG $ if they were mapped to $ W $.
		During the simulation of $ \hash $, if $ \fgvrf $ aborts, then there exists $ W' \neq W $ such that $ \anonymouskeymap[m,W'] = \pk^* $. Remark that it is not possible because if it happens it means that $ hX^* = W' \neq W  $ where $ \pkeys[X^*] = \pk^* $, but also $ W = hX^* $. 
		Therefore, $ \simulator $ never aborts during the simulation of $ \hash $.
		
	\eprint{	We note that the anonymous keys for honest parties generated by $ \fgvrf $ are independent from honest commitment keys. Therefore, if $ X^* = h^{-1}W $ is an honest verification key, $ \simulator $ returns a random value because  $ \evaluationslist[m,W] $ is not defined or will not be defined in $ \fgvrf $ in this case except with a negligible probability. If it ever happens i.e., if $ \fgvrf $ selects randomly $ W = hX^* $, $ \env $ distinguishes the simulation via honest signature verification in the real world. So, this case is covered in our simulation in Figure \ref{oracle:H'}.}{}
		
		\begin{figure}
			\begin{minipage}{4cm}
			\centering
			\noindent\fbox{%
				\parbox{4cm}{%
					\underline{\textbf{Oracle $ \hashG $}} \\
					\textbf{Input:} $ m $ \\
					\textbf{if} $\mathtt{oracle\_queries\_gg}[m] = \perp  $
					
					\tab{$ h \leftsample \FF_p $}
					
					%					\tab{\textbf{for all} $ X \in \ring $}
					%					
					%					\tab{$ W =  hX $}
					%					
					%					\tabdbl{\textbf{if} $ W \in \anonymouskeylist $: \textsc{Abort}}
					%					
					%					\tabdbl{\textbf{else:} \textbf{add} $ W $ \textbf{to} $ \anonymouskeylist $}
					
					\tab{$ P \leftarrow hG $} 
					
					\tab{$\mathtt{oracle\_queries\_gg}[m] := h$}
					
					\textbf{else}:
					
					\tab{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m] $}
					
					\tab{$ P \leftarrow hG$}
					
					\textbf{return $ \In$}
					
			}}	
			\caption{The random oracle $ \hashG $}
			\label{oracle:HgnoPK}
		
	\end{minipage}
\hfill
	\begin{minipage}{7cm}
			\centering
			
			\noindent\fbox{%
				\parbox{7cm}{%
					\underline{\textbf{Oracle $ \hash$}} \\
					\textbf{Input:} $ m,W $ 
					
					\textbf{if} $ \mathtt{oracle\_queries\_h}[m, W] \neq \perp $
					
					\tab{\textbf{return $  \mathtt{oracle\_queries\_h}[m,  W] $}}
					
					%					\textbf{send} $ (\oramsg{request}, \sid, \emptyset,W, m) $ \textbf{to} $ \fgvrf $
					%					
					%					\textbf{receive} $ (\oramsg{requests}, \sid, \emptyset, W, m, \setsym{L}_\sigma, y) $ \textbf{from} $ \fgvrf $
					
					%					\textbf{if} $ y = \perp $
					
					{$ P \leftarrow \hashG(m) $}
					
					{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m] $}
					
					{$ X^* := h^{-1}W $ // candidate commitment key} 
					
					{{\textbf{if} $\skeys[X^*] = \perp$ }} 
					
					\tab{\textbf{if} $ \pkeys[X^*]  = \perp$}
					
					\tabdbl{$ \pk^* \leftsample \grE $} %TODO put the space of pk's
					
					\tabdbl{$ \pkeys[X^*] \leftarrow \pk^* $}
					
					\tab{\textbf{send} $ (\oramsg{eval}, \sid, W, \pkeys[X^*] , m) $ \textbf{to} $ \fgvrf $}
					
					\tab{\textbf{if} $ \fgvrf $ ignores: \abort}
					
					\tab{\textbf{receive} $ (\oramsg{evaluated}, \sid, W, m, y) $ \textbf{from} $ \fgvrf $}
					
					\tab{$  \mathtt{oracle\_queries\_h}[m, W]:=y $}
					
					{\textbf{else:} }
					
					\tab{$ y \leftsample \FF_p $}
					
					\tab{$  \mathtt{oracle\_queries\_h}[m,  W]:=y $}
					%					{\textbf{else:} $ \mathtt{oracle\_queries\_h}[m, \ring, W]  = \perp$}
					%					
					%					%\tab{\textbf{return} \textsc{Abort}}
					%					\tab{$ y \leftsample \bin^\lambda $}
					%					
					%					\tab{$\mathtt{oracle\_queries\_h}[m, \ring, W] := y $}
					
					%	\textbf{else:} $  \mathtt{oracle\_queries\_h}[m,  W]:=y $
					
					\textbf{return $  \mathtt{oracle\_queries\_h}[m,  W] $}
					
			}}	
			\caption{The random oracle $ \hash $}
			\label{oracle:HnoPK}
		\end{minipage}
		\end{figure}
		
		The simulation of the random oracle $ \hash_p $ (See Figure \ref{oracle:H'}) checks whether the random oracle query $ (\ring,m,W,\compk,R,R_m) $ is an $ \rcom $ verification query before answering. \eprint{For this, it checks whether $ \fgvrf $ has a recorded valid signature for the message $ m $ and the ring $ \ring $ with the anonymous key $ W $. If there exists such valid signature where $ \compk $ is part of it, $ \simulator $ checks whether the first proof of the signature $ (c,s_1, s_2) $ generates $ R, R_m $ as in $ \rVRF.\Verify $ in order to make sure that it is a $ \rcom $ verification query. If it is the case, it assigns $ c $ as an answer of $ \hash_p (\ring,m,W,\compk,R,R_m) $ so that $ \rcom $ verifies. However, if this input has already been set to another value which is not equal to $ c $ or $ W $ is a pre-output of an honest key, then $ \simulator $ aborts because the output of the real world for this signature and the ideal world will be different.}{}
		We remind that if an anonymous key $ W $ of an honest party  for a message $ m $ sampled by $ \fgvrf $ equals to a pre-output generated by $ \rVRF.\Sign $  for the same honest party's key and the message $ m $, then $ \env $ can distinguish the ideal and real world outputs because the evaluation value in the ideal world and real world for $ m,W $ will be different because of the simulation of the random oracle $ \hash $ i.e., $ \mathtt{oracle\_queries\_h}[m,W] \neq \evaluationslist[m,W] $.  Therefore, $ \simulator $ aborts if it is ever happen.
		
		\begin{figure}
			\centering
			
			\noindent\fbox{%
				\parbox{\columnwidth}{%
					\underline{\textbf{Oracle $ \hash_p $}} \\
					\textbf{Input:} $ (\aux', \msg,\compk,W,R,R_m) $ \\					
					
					\textbf{parse} $ \aux' $ as $\tmpaux $
					
					\textbf{send} $ (\oramsg{request\_signatures},\sid, \aux, W,\msg) $
					
					\textbf{receive} $ (\oramsg{signatures},\sid,\msg, \setsym{L}_\sigma) $
					
					\textbf{if} $ \exists \sigma \in \setsym{L}_\sigma $ where $ \compk   \in \sigma $ \textbf{and} $ \NIZK_{\Rring}.\Verify((\compk,\comring);\piring) \rightarrow 1 $
					
					\tab{\textbf{get} $ \pi_1 = (c,s_1, s_2) \in \sigma $} 
					
					\tab{\textbf{if} $ R = s_1\genG + s_2 \genB -c\compk, R_m = s_1 \hashG(m) - c W $}  
					
					\tabdbl{$ h := \mathtt{oracle\_queries\_gg}[m,W] $ }
					
					\tabdbl{\textbf{if} $ \mathtt{oracle\_queries\_h\_CP}[\aux, m,\compk,W,R,R_m]  = \perp $}
					
					\tabdbldbl{$ \mathtt{oracle\_queries\_h\_CP}[\aux, m,\compk,W,R,R_m]  := c$}
					
					\tabdbl{\textbf{else if} $( \mathtt{oracle\_queries\_h\_CP}[\aux, m,\compk,W,R,R_m]  \neq c $ }
					
					\tabdbl{\textbf{or} $ X^* = h^{-1}W \in \hkeys) $: \abort}
					
					
					\textbf{if} $ \mathtt{oracle\_queries\_h\_CP}[\aux, m,\compk,W,R,R_m]  = \perp $
					
					\tab{$ c \leftsample \FF_p $}
					
					\tab{$ \mathtt{oracle\_queries\_h\_CP}[\aux, m,\compk,W,R,R_m]  := c$}
					
					{\textbf{return} $ \mathtt{oracle\_queries\_h\_CP}[\aux, m,\compk,W,R,R_m] $}
					
			}}
			\caption{The random oracle $ \hash_p $}
			\label{oracle:H'}
		\end{figure}
		
		
		%		\item \textbf{[Simulation of $ \oramsg{sign} $]} 
		%		The simulator has a table  $\preoutputlist $ to keep the pre-outputs that it selects for each input and the ring of public keys. 
		%		Upon receiving $(\oramsg{sign}, \sid, \ring, m, y)$  from the functionality $\fgvrf$, $ \simulator $ generates the signature $ \sigma $ as follows:
		%		
		%		For the first proof, it samples $ c, s_1, s_2 \in \FF_p $ and $ \compk, W \in \GG$. Then, it lets the first proof be $\pi_1 =  (c, s_1, s_2) $. 
		%		In addition, it sets $ R = sG+ \delta K+ c\compk $ and $ R_m = s \hashG(m, \ring)+ cW $ and maps the input $ \ring,m, W,\compk, R, R_m$ to $ c $ in the table of the random oracle $ \hash_p $ so that $ \pi_1 $ verifies in the real-world execution.  
		%		It adds $ W $ to the list $ \preoutputlist[m, \ring] $.
		%		
		%		$ \simulator $ gets the trapdoor $ \tau $ that it generated during the simulation of $ \gcrs $ to simulate the second proof. Then, it runs $ \mathsf{SNARK}.\mathsf{Simulate}(\rsnark,\tau, crs) $ and obtains $ \pi_2 $.
		%		
		%		In the end, $ \simulator $  responds by sending the message $(\oramsg{signature}, \sid, \ring, m, \sigma = (\pi_1, \pi_2, \compk, W))$ to the $ \fgvrf $.  It also lets $ \mathtt{oracle\_queries\_h}[m, \ring, W] $ be $ y $, if it is not defined yet. If it is defined with another value $ y' \neq y $, then it aborts.
		%TODO: Talk about this abort case happens with a negl probability. 
		
		
		 \noindent\textbf{[Simulation of $ \oramsg{verify} $]} Upon receiving  $(\oramsg{verify}, \sid, \ring,W, \aux,\msg, \sigma)$ from the functionality $\fgvrf$, $ \simulator $ runs the two NIZK verification algorithms run for $ \rcom, \rsnark $ with the input $ \comring, \msg, \sigma, W $ described in $ \rVRF.\Verify $ algorithm of ring VRF protocol if $ \sigma $ can be parsed as $ (\pi_1,\pi_2, \compk, \comring) $. If  all verify, it sets $ b_{\simulator} =1 $. Otherwise it sets $ b_{\simulator} =0  $.
		
		\noindent If $ b_\simulator = 1 $, it sets $ X = h^{-1} W$ where $ h = \mathtt{oracle\_queries\_gg}[m] $. Then it obtains $ \pk  = \pkeys[X]$ if it exists. If it does not exist, it picks a $ \pk  $ which is not stored in $ \pkeys $ and sets $ \pkeys[X] = \pk $. Then sends  $ (\oramsg{verified}, \sid, \ring, W,\aux, m, \sigma, b_\simulator, \pkeys[X]) $ to $ \fgvrf $ and receives back $ (\oramsg{verified}, \sid, \ring, W, \aux, m, \sigma, y, b) $. 
			
			- If $ b \neq b_\simulator $, it means that the signature is not a valid signature in the ideal world, while it is in the real world. So, $ \simulator $ aborts in this case.
				If $ \fgvrf $ does not verify a ring signature even if  it is verified in the real world, $ \fgvrf $ is in either C3-\ref{cond:uniqueness}, \ref{cond:forgery} or C3-\ref{cond:differentWforsamepk}.
				If $ \fgvrf $ is in C3-\ref{cond:uniqueness}, it means that $ \counter[m,\ring] > |\ring_m| $. If $ \fgvrf $ is in C3-\ref{cond:forgery}, it means that $ \pk$ belongs to an honest party but this honest party never signs $ m $ for  $ \ring $. So, $ \sigma $ is a forgery.	 If $ \fgvrf $ is in C3- \ref{cond:differentWforsamepk}, it means that there exists $ W' \neq W $ where $ \anonymouskeymap[m,W'] = \pk$. If $ [m,W'] $ is stored before, it means that $ \simulator $ obtained $ W' = hX $ where $ h = \mathtt{oracle\_queries\_h}[m] $ but it is impossible to happen since $ W = hX $.
				
			  - If $ b = b_\simulator $, it sets $ \mathtt{oracle\_queries\_h}[m,W] = y $, if it is not defined before.
				% In short, if $ \simulator $ aborts because $ b\neq b_\simulator $ it means either $ W $ of an honest party is not unique and $ \adv $ in the real world generates a forgery signature of $ (m, \ring, \sigma) $ with $ W $ or the adversary in the real world generates anonymous keys for $ (m, \ring) $ more than the number of adversarial keys in $ \ring $.
				%				 
				
				%	\item If $ b = b_\simulator $, set $ \mathtt{oracle\_queries\_h}[m, W] = y $. Here, if $ \sigma $ is a signature of an honest party, $ \simulator $ sets its output with respect to the output selected by $ \fgvrf $. 
				%    Remark that we do not need to set $ \mathtt{oracle\_queries\_h\_CP} $ because it already verifies in the real world.
			
		 \noindent If $ b_\simulator = 0 $, it sets $ \pk = \perp $ and sends  $ (\oramsg{verified}, \sid, \ring, W,\aux, m, \sigma, b_\simulator, X) $ to $ \fgvrf $. Then, $ \simulator $ receives back $ (\oramsg{verified}, \sid, \ring, W, \aux,m, \sigma, \perp, 0) $. 
			%			\begin{itemize}
				%				\item If $ b \neq b_\simulator $, it means that it was a signature of an honest party and $ \NIZK.\Verify $ for $ \rcom $ does not validate in the real world. So, $ \simulator $ sets $ \mathtt{oracle\_queries\_h}[m, \ring,W] = y $ and $ \mathtt{oracle\_queries\_h\_CP}[\ring, m, W, \compk, R', R_m'] = c $ where $ R' = s\genG + \delta K+ c\compk  $, $ R_m = s \hashG(m,\ring) + cW$. 
				%				Now, the signature verifies in the real world as well.
				%				\item If $ b = b_\simulator $, $ \simulator $ doesn't need to do anything.
				%			\end{itemize}
			


	Now, we need to show that the outputs of honest parties in the ideal world are indistinguishable from the honest parties in the real world. 
	
	\begin{lemma}\label{lem:honestoutput}
			The outputs of honest parties in the real protocol \name\ are indistinguishable from the output of the honest parties in $ \fgvrf $.
	\end{lemma}
		
		\begin{proof}
			\eprint{Clearly, the evaluation outputs of the ring signatures in the ideal world identical to the real world protocol because  the outputs are randomly selected by $ \fgvrf $ as the random oracle $ \hash $ in the real protocol.}{The evaluation outputs are indistinguishable.} The only difference between two world's output is the ring signatures of honest parties (See Algorithm \ref{alg:gensign}) since the pre-output $ W $ and $ \pi_{eval} $ are generated differently in Algorithm \ref{alg:gensign} than $ \rVRF.\Sign $. \eprint{The distribution of $ \pi_{eval} = (c,s_1, s_2) $ and $ \compk $ generated by Algorithm \ref{alg:gensign} and the distribution of $ \pi_{eval} = (c,s_1, s_2) $ and $ \compk $ generated by $ \rVRF.\Sign $ are from uniform distribution so they are indistinguishable.}{The distribution of $ \pi_{eval}  $ and $ \compk $ in two worlds are the same.} So, we are left to show that the anonymous key $ W $ selected randomly from $ \grE $ and pre-output $	 W $ generated by $ \rVRF.\Sign $ are indistinguishable given $ \pk  $. 
			
			\textbf{Case 1 ($ \pk \neq x \genG$):} If  $ \pk \neq x \genG$, then  $ \pk $ is uniformly random and independent from $ x $. Therefore, $ \env $ can distinguish ideal world honest signatures from the real world honest signatures at most with probability $ \frac{1}{2} $.
			
			\textbf{Case 2 ($ \pk = x \genG$):} We  show this under the assumption that the DDH problem  is hard.  In other words, we show that if there exists a distinguisher $ \mathcal{D} $ that distinguishes honest signatures in the ideal world and honest signatures in the real protocol then we construct another adversary $ \bdv $ which breaks the DDH problem. 
			We use the hybrid argument to show this.
			We define hybrid simulations $ H_{i} $ where  the signatures of first $ i $ honest parties are computed as described in $ \rVRF.\Sign $ and the rest are computed as in $ \fgvrf $. Without loss of generality, $ \user_1, \user_2, \ldots, \user_{n_h} $ are the honest parties. Thus, $ H_0 $ is equivalent to the honest of the ideal protocol  and $ H_{n_h}  $ is equivalent to  honest signatures in the real world.  We construct an adversary $ \bdv $ that breaks the DDH problem given that there exists an adversary $ \mathcal{D} $ that distinguishes hybrid games $ H_i $ and $ H_{i + 1} $ for $ 0 \leq i < n_h $. $\bdv $ receives the DDH challenges $ X,Y, Z \in \GG $ from the DDH game and simulates the game against $ \mathcal{D} $ as follows. 
			Then $ \bdv $ runs a simulated copy of $ \env $ and starts to simulate $ \fgvrf $ and $ \simulator $ for $ \env $. For this, it first runs the simulated copy of $ \adv $ as $ \simulator $ does. $  \bdv $ publishes $ \GG, \genG = Y, \genB $ as parameters of the ring VRF protocol. $\bdv $ generates the public key of all  honest parties' key as usual by running $ \rVRF.\KeyGen$ as $ \simulator $ does except party $ \user_{i+1} $. It lets the public key of $ \user_{i + 1} $ be $ X $.
		
%			\begin{algorithm}
%				
%				\caption{$\gen^{ind}_{sign}(\ring,\openring,W,\{X,\pk\},\aux,\msg)$}
%				\label{alg:gensignind}	 	
%				\begin{algorithmic}[1]
%					\State $ \compk \leftsample \grE$
%					\State $ \pi_{eval}  \leftarrow \NIZK_{\rcom}.\Simulate(\compk,W,\hashG(\msg)) $
%					%\State $ \pi_{eval} \leftarrow \NIZK.\mathsf{Simulate}(\rcom, (G, \genB,\GG,\compk,W,\In)) $
%					%\State \textbf{send} $(\oramsg{learn\_\tau},\sid)  $ to $ \gcrs $
%					%\State \textbf{receive} $(\oramsg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
%					\If{$ \pk = \OpenRing(\comring,\openring) $}
%					\State $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\Simulate((\comring, \compk)) $ 
%					\State\Return$ \sigma = (\pi_{eval},\pi_{ring},\compk,\comring,W) $
%					\EndIf
%				\end{algorithmic}
%				
%			\end{algorithm}
		
			
			While simulating $ \fgvrf $, $\bdv $ simulates the ring signatures of first $ i $ parties by running $ \rVRF.\Sign $ and the parties $ \user_{i+2}, \ldots, \user_{n_h} $ by running Algorithm \ref{alg:gensign} where $ W $ is selected randomly. The simulation of $ \user_{i + 1} $ is different.  Whenever $ \user_{i+1} $ needs to sign a message $ m$, it obtains $ \In = \hashG(m) = hY $ from $ \mathtt{oracle\_queries\_gg} $ and lets $ W = hZ $. Then it lets $ \compk = X + \openpk\genB $, lets  $ \pieval \rightarrow \NIZK_{\rcom}.\Simulate(\compk,W,\hashG(m)) $ and  $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\Simulate((\comring, \compk)) $.  Remark that if $ (X,Y,Z)$ is a DH triple (i.e., $  \mathsf{DH}(X,Y,Z) \rightarrow 1 $), $ \user_{i+1} $ is simulated as in \name \ because $ W = x\In$ in this case. Otherwise, $ \user_{i+1} $ is simulated as in the ideal world because $ W $ is random. So, if $  \mathsf{DH}(X,Y,Z)  \rightarrow 1$, $\simulator $ simulates $ H_{i+1} $. Otherwise, it simulates $ H_{i} $. In the end of the simulation, if $ \mathcal{D} $ outputs $ i $, $\simulator $ outputs $ 0 $ meaning $  \mathsf{DH}(X,Y,Z) \rightarrow 0$. Otherwise, it outputs $ i + 1 $. The success probability of $\simulator $ is equal to the success probability of $\mathcal{D} $ which distinguishes $ H_i $ and $ H_{i +1} $. Since DDH problem is hard, $\simulator $ has negligible advantage in the DDH game. So, $ \mathcal{D} $ has a negligible advantage too. Hence, from the hybrid argument, we can conclude that $ H_0    $ which corresponds the output of honest parties in  the ring VRF protocol and $ H_q  $ which corresponds to  the output of honest parties in ideal world are indistinguishable.
			
			
		\end{proof}	
		This concludes the proof of showing the output of honest parties in the ideal world are indistinguishable from the output of the honest parties in the real protocol.
		Next we show that the simulation executed by $ \simulator $ against $ \adv $ is indistinguishable from the real protocol execution.
		
		\begin{lemma} \label{lem:simulation-ind}
			The view of $ \adv $ in its interaction with the simulator $ \simulator $ is indistinguishable from the view of $ \adv $ in its interaction with real honest parties.
		\end{lemma}
		
		
		\begin{proof}
			The  simulation against the real world adversary $ \adv $ is identical to the real protocol except the output of the honest parties and cases where $ \simulator $ aborts. 
			We show that the abort cases happen with a negligible probability during the simulation. $ \simulator $ aborts during the simulation of random oracles \eprint{$ \hash $ and}{} $ \hash_p $ and during the simulation of verification.\eprint{ We have already explained that the abort case during the simulation of $ \hash $ cannot happen.}{} The abort case happens in the simulation of $ \hash_p $ if $ W = hX $ where $ X = \sk\genG $ or if $ \mathtt{oracle\_queries\_h\_CP}[\comring,m,W,\compk,R,R_m] $ has already been defined by a value which is different than $ c $. \eprint{The first case happens in $ \hash_p $ if $ \fgvrf $ selects a random $ W \in \GG$ for an anonymous key of $ m, \pk  $ for the honest party with the other key $ X  $ and the random oracle $ \hashG $ selects a random $ h \in \FF_p  $ where $ \hashG(m) = hG $ and $ W = hX $. Clearly, this can happen with a negligible probability in $ \secparam $. The 
			second case happens in $ \hash_p $ if $ \adv $ queries with the input $ (\comring,m,W,\compk,R,R_m) $ before $ (\pi_1,\pi_2,\compk,\comring,W) $ generated by $ \gen_{sign} $. Since $ \compk $ is randomly selected by $ \fgvrf $, the probability that $ \adv $ guesses $ \compk $ before it is generated is negligible.}{They can be clearly happen with negligible probability.}
			Now, we are left with the abort case during the verification.
			For this, we show that if there exists an adversary $ \adv $ which makes $ \simulator $ abort during the simulation, then we construct another adversary $ \bdv $ which breaks either the CDH problem or the binding property of $ \rVRF.\KeyGen $.
			
			Consider a CDH game in a prime $ p $-order group  $ \grE $ with the challenges $ \genG,U, V \in \grE$. The CDH challenges are given to the simulator $ \bdv $. Then $ \bdv $ runs a simulated copy of $ \env $ and starts to simulate $ \fgvrf $ and $ \simulator $ for $ \env $. For this, it first runs the simulated copy of $ \adv $ as $ \simulator $ does. $ \bdv $ provides $ (\grE, p, \genG , \genB) $ as a public parameter of the ring VRF protocol to $ \adv $.	For the public keys of honest parties, $ \bdv $ picks a random $ r_x\in \FF_p $ and sets $ X =r_xV$. If $ \rVRF.\KeyGen $ is defined as $ \pk = \sk \genG $, it lets $ \pk $ be $ X $ otherwise it picks a random public key $ \pk $. Whenever $ \bdv $ needs to generate a ring signature for $ m $ for an honest party with a public key $ \pk $ mapped to $X $, it behaves exactly as $ \fgvrf $ except that it runs   Algorithm \ref{alg:gensignbdv} to generate the signature. 
%			Remark that $ \bdv$  never needs to know the secret key of honest parties to simulate them since $ \bdv $ selects anonymous keys randomly  and generates the ring signatures  without the secret keys. Since the public key generated by $ \rVRF.\KeyGen $ is random and independent from the secret key, $ \bdv $'s key generation is indistinguishable from $ \simulator $'s key generation.
			
			%			
			%			\begin{algorithm}
				%				\caption{$\gen_{W}(X, m)$}
				%				\label{alg:genWbdv}	 	
				%				\begin{algorithmic}[1]
					%					\If{$ DB_W[m, X] = \perp $}
					%					\State $ W \leftsample \GG$
					%					\State $ DB_W[m, X] := W $
					%				%	\State \textbf{add} $ W $ to list $ \anonymouskeylist[m,\ring] $
					%					\EndIf
					%					\State \textbf{return} $ DB_W[m, X] $
					%				\end{algorithmic}
				%			\end{algorithm}
			
			
			\begin{algorithm}
				\caption{$\gen_{sign}(\ring,W,\{X,\pk\},\aux,m)$}
				\label{alg:gensignbdv}	 	
				\begin{algorithmic}[1]
%					\State $ c,s_1, s_2 \leftsample \FF_p $
%					\State $ \pi_{eval}  \leftarrow (c,s_1, s_2)$
					\State $ \openpk \leftsample \FF_p $
					\State $ \compk =  X + \openpk \, K$
					\State $ \pieval \leftarrow \NIZK_{\mathcal{R}_{eval}}.\Simulate(\compk, W,\hashG(m)) $
					\State $ \comring, \openring \leftarrow \rVRF.\CommitRing(\ring) $
					\State $ \piring \leftarrow \NIZK_{\rsnark}.\Simulate(\comring, \compk) $ 
%					\State $ R' = s\genG +\delta K + c\compk$
%					\State $ R_m = s\hashG(m) + c W $
%					\State $ \aux' = \tmpaux $
%					\State $ \mathtt{oracle\_queries\_h\_CP}[\aux',m, \compk,W,R',R'_m] = c$						
					\State\Return$ \sigma = (\pi_{eval},\pi_{ring},\compk,\comring,W) $
				\end{algorithmic}
				
			\end{algorithm}
			
			
			The  signature of an honest party by $ \fgvrf$ the  signature generated by $ \bdv $ are the same. The only difference is that now $ \bdv $ does not need to set $ \hash_p $ so that $ \pieval $ verifies because $ \Gen_{sign} $ in Algorithm \ref{alg:gensignbdv} does it while simulating the proof for $ \rel_{eval} $. \eprint{Therefore, the simulation of $ \hash_p $ is simulated as a usual random oracle by $ \bdv $.}{$ \hash_p $ is simulated as a usual random oracle by $ \bdv$.}				
			$ \bdv $  sets up $ \evaluationslist[m,W] $ by querying queries $ m,W $ to  $ \hash $ described. \eprint{$ \bdv $ simulates the random oracle $ \hash $ as a usual random oracle.
			The only difference from the simulation of $ \hash $ by $ \simulator $ is that $ \bdv $ does not ask for the output of $ \hash(m,W) $ to $ \fgvrf $ but it does not change the simulation because now $\fgvrf $ asks for it.  Remark that since $ \hashG $ is not simulated as in Figure \ref{oracle:HgnoPK}, $ \bdv $ cannot check whether $ W $ is an anonymous key generated by an honest secret key or not.  However, it does not need this information because $ \hash $ is simulated as a usual random oracle. $ \bdv $ also simulates $ \hash_\ring $ for the ring commitments as a usual random oracle. 			
			Simulation of $ \hashG $ by $ \bdv $ returns $ hU $ instead of $ hG $. The simulation of $ \hashG $ is indistinguishable from the simulation of $ \hashG $ in Figure \ref{oracle:HgnoPK}. }{}
			
%			\begin{figure}
%				\centering
%				
%				\noindent\fbox{%
%					\parbox{\columnwidth}{%
%						\underline{\textbf{Oracle $ \hash$}} \\
%						\textbf{Input:} $ m,W $ 
%						
%						\textbf{if} $ \mathtt{oracle\_queries\_h}[m,  W] = \perp $
%						
%						\tab{$ y \leftsample \{0,1\}^{\ell_\rVRF} $}
%						
%						\tab{$  \mathtt{oracle\_queries\_h}[m,  W]:=y $}
%						
%						
%						\textbf{return $  \mathtt{oracle\_queries\_h}[m, W] $}
%						
%				}}	
%				\caption{The random oracle $ \hash $}
%				\label{oracle:HbyB}
%			\end{figure}
			
%			\begin{figure}
%				\centering
%				
%				\noindent\fbox{%
%					\parbox{\columnwidth}{%
%						\underline{\textbf{Oracle $ \hashG $}} \\
%						\textbf{Input:} $ m$ \\
%						\textbf{if} $\mathtt{oracle\_queries\_gg}[m] = \perp  $
%						
%						\tab{$ h \leftsample \FF_p $}
%						
%						
%						\tab{$ P \leftarrow hU $} 
%						
%						\tab{$\mathtt{oracle\_queries\_gg}[m] := h$}
%						
%						\textbf{else}:
%						
%						\tab{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m] $}
%						
%						\tab{$ P \leftarrow hU$}
%						
%						\textbf{return $ \In$}
%						
%				}}	
%				\caption{The random oracle $ \hashG $}
%				\label{oracle:HgbyB}
%			\end{figure}

			
			During the simulation, when $ \adv $ outputs a signature $ \sigma = (\pi_{eval},\pi_{ring},\compk,\comring,W) $ of message $ m $ with $ \aux $ which is not recorded in $ \fgvrf $'s record, $ \bdv $ runs $ \rVRF.\Verify(\comring,m, \aux, \sigma) $. If it verifies, it finds the corresponding ring $ \ring $ of $ \comring $ by checking the random oracle $ \hash_\ring $'s database. Remark that there exists $ \ring $ where Merkle tree root of $ \ring $ is $ \comring $ because if it was not the case $ \sigma $ would not verify which also checks  $ \pi_{ring} $. 
			Then it runs the extractor algorithm of $ \NIZK_{\Rring} $ and obtains $ X = \compk  - \openpk \, \genB $. 
			If $ \pk = \rVRF.\OpenRing(\comring,\openring) $ is not an honest key then $\bdv $ adds $ W $  to $ \anonymouskeylist[m, \ring] $.  If $ \pk $ is not a malicious key but $ X $ is  generated for honest parties by $ \bdv $ while simulating $ \simulator $, $ \bdv $ aborts \footnote{This case never happens if $ \pk  $ is defined $ \sk\genG $}. The abort case happen with a negligible probability because all the outputs seen by the adversary are independent from $ X $.
			Otherwise, it  runs the extractor algorithm of $ \NIZK_{\rcom} $ and obtains $(\hat{\sk},\hat{\openpk} )$ such that $ \compk = \hat{\sk}\genG + \hat{\openpk} \, \genB $ and $ W = \hat{\sk} \hashG(m) $. If  $ W \notin \anonymouskeylist[m, \ring] $, $ \bdv $ increments  $ \counter[m,\ring] $ and adds $ W $ to $ \anonymouskeylist[m,\ring] $ for $ \Rring $.

			If $ X  $ is a key which is generated by $ \bdv $ and $ X = \hat{\sk}G $, $ \bdv $ solves the CDH problem as follows: $ W = \hat{\sk} h U $ where $ h = \mathtt{oracle\_queries\_gg}[m] $. Since $ X = r V $, $ W = \hat{\sk}huG =rhuV $. So, $ \bdv $ outputs $ r^{-1}h^{-1}W $ as a CDH solution and simulation ends. Remark that this case happens when $ \simulator $ aborts because of \ref{cond:forgery}.
			
			If $ \anonymouskeylist[m,\ring] \geq |\ring_{mal}| =t$, $ \bdv $ obtains all the signatures $ \{\sigma_i\}_{i =1}^t $ that make $ \bdv $ to add an anonymous key to $ \anonymouskeylist[m,\ring] $. Then it solves the CDH problem as follows: Remark that this case happens when $ \simulator $ aborts because of \ref{cond:uniqueness}.
			
			For all $ \sigma_j = (\pieval,\piring,\compk_j,W_j) \in \{\sigma_i\}_{i =1}^t $, $ \bdv $ runs extractor for $ \Rring $ and obtains $\openring_j, \openpk_j$. Then it obtains the public key $ \pk_j = \rVRF.\OpenRing(\ring, \openring_j) $ where $ \pk_j \in \ring $ and  $ X_j = \compk- \openpk \genB $. Then it adds $ X_j $ to a list $ \setsym{X}  $ and $ \pk_j $ to a set $ \setsym{PK} $. One of the following cases happens:
			
		
			- All $ X_j $ in $ \setsym{X} $ are different and $ |\setsym{PK}| \leq t $, $ \bdv $ aborts: Each $ \pk \in \setsym{PK} $ commits to a secret key $ \sk $. Since it is a binding commitment there exists one opening $ r $ except with a negligible probability. Since $ \piring $ verifies in $ \Rring $ whether $ \rel_{\pk} $ is satisfied, if  $ X_j $ in $ \setsym{X} $ are different and $ |\setsym{PK}| \leq t $, means that the binding property is broken. Therefore, $ \bdv  $ aborts with a negligible probability. We note $ \bdv $ can be in this case only if $ \pk \neq \sk \genG $.
			
			- All $ X_j $ in $ \setsym{X} $ are different and $ |\setsym{PK}| > t $: If $ \bdv $ is in this case, it means that there exists one commitment public key $ X_a \in \setsym{X} $ which belongs to an honest party or . Then $ \bdv $ runs the extractor algorithm of $ \NIZK_{\rcom} $ and obtains $ \hat{\sk}_a, \hat{\openpk} $ such that $ \compk_a = \hat{\sk}_a\genG + \hat{\openpk}_a \,\genB $ and $ W_a = \hat{\sk}_a \hashG(m) $.  If $ \bdv $ is in this case, $ \hat{\sk}_a\genG\neq X_a $ because otherwise it would solve the CDH as described before. Therefore, $ \openpk_a \neq \hat{\openpk}_a $. Since $ X_a + \openpk_a \, \genB = \hat{\sk}_a\genG + \hat{\openpk}_a \,\genB  $ and $ X_a = r_aV $ where $ r_a $ is generated by $ \bdv $ during the key generation process, $ \bdv $ obtains a representation of $ V = \gamma \genG + \delta \genB $ where $ \gamma = \hat{\sk}_ar^{-1}_a  $ and $ \delta = (\hat{\openpk}_a -\openpk)\,r_a^{-1} $. Then $ \bdv $ stores $ (\gamma, \delta) $ to a list $ \mathsf{rep} $. If $ \mathsf{rep} $ does not include another element $ (\gamma', \delta')  \neq (\gamma, \delta) $, $ \bdv $ rewinds $ \adv $ to the beginning with a new random coin.  Otherwise, it obtains $ (\gamma', \delta') $ which is another representation of $ V $ i.e., $ V = \gamma' \genG + \delta' \genB $. Thus, $ \bdv $ can find discrete logarithm of $ V $ on base $ G $ which is $ v = \gamma + \delta \theta $ where $ \theta = (\gamma - \gamma')(\delta' - \delta)^{-1} $. $ \bdv $ outputs $ vU $ as a CDH solution.
				
				
			- There exists at least two $ X_a,X_b \in \setsym{X} $ where $ X_a = X_b $. $ \bdv $ runs the extractor algorithm of $ \NIZK_{\rcom} $ for $ \pi_{ring_a} $ and $ \pi_{ring_b}  $ and obtains $(\hat{\sk}_a,\hat{\openpk}_a )$ and $(\hat{\sk}_b,\hat{\openpk}_b )$, respectively\eprint{ such that $ \compk_a = \hat{\sk}_a\genG + \hat{\openpk}_a \, \genB \compk_b = \hat{\sk}_b\genG + \hat{\openpk}_b \, \genB $ and $ W_a = \hat{\sk}_a \hashG(m), W_b = \hat{\sk}_b \hashG(m) $}{}. Since $ W_a \neq W_b $, $ \hat{\sk}_a \neq \hat{\sk}_b $.  So, $ \bdv $ can obtain  two different and non trivial representation of $ X_a = X_b $ i.e., $ X_a = X_b = \hat{\sk}_a\genG + (\hat{\openpk}_a - \openpk_a) \, \genB = \hat{\sk}_b\genG + (\hat{\openpk}_b - \openpk_b) \, \genB  $. Thus, $ \bdv $ finds the discrete logarithm of $ K = U $ in base $ G $ which is $ u = \frac{\hat{\sk}_a - \hat{\sk}_b}{\hat{\openpk}_a -\openpk_a -\hat{\openpk}_b + \openpk_b} $. $ \bdv $ outputs $ uV $ as a CDH solution.

			
			
			
			
			
			
			
			
			
			
			
			
			%	
			%		
			%		
			%			$ \bdv $ solves CDH if $ \bdv $ is in the abort case of simulation of $ \hash$ in Figure \ref{oracle:H} by outputting $ r^{-1}h^{-1}W $ is the CDH solution of $ U,V $. $ r^{-1}h^{-1}W $ is the CDH solution because $ vU $ is a solution of $ CDH $ where $ V =  $
			%		
			%		is in this case $ \bdv $ outputs  $ r^{-1}h^{-1}W $  where $ X^* = rV $ and $ h = \mathtt{oracle\_queries\_gg}[m,\ring] $ and simulation ends. Remark that if $ \bdv $ aborts during the simulation of $ \hash $ it means that $ X^* $ belongs to an honest party and $ X^* =  h^{-1}W = rV = rvG$.  Therefore, $ r^{-1}h^{-1}W $ is the CDH solution of $ U,V $.
			%				  
			%		During the simulation if $ \bdv $ sees a valid forgery ring signature  $ m, \ring, \sigma = (\pi_{eval}, \pi_{ring}, C, W) $ where $ W $ is an anonymous key generated by $ \bdv $ for $ (m',\ring') \neq (m, \ring) $, $ \bdv $ aborts. $ \Pr[x\hashG(m',\ring') = W; xG \in \ring'| \ring',W] $ is negligible because $ \hashG $ is a random oracle.
			%		%TODO exact probability
			%				  
			
			%		During the simulation if $ \bdv $ sees a forgery ring signature  $ m, \ring, \sigma = (\pi_{eval}, \pi_{ring}, C, W) $ where $ X = h^{-1}W $ is an honest key, then $ \bdv $ does the following: It runs the extractor algorithms on $ \pi_{ring} $ i.e., $ \ext(\rsnark,..) $ and obtains $ X' \in \ring $ and $ \openpk' $ where $ C = X' + \openpk' K $ and $ \pi_{eval} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \openpk$ where $ C = x\genG + \openpk K$ and $ W = x\hashG(m, \ring)= xhV$.  Then, $ \bdv $ outputs the CDH of $ U, V $ which is $r^{-1}xU  $. This is correct CDH solution because $ X= rV = xG $, $ V= r^{-1}xG $.
			%		We remark  a forgery signature corresponds to the abort case of $ \simulator $ during the verification because $ \fgvrf $ is in \ref{cond:forgerymalicious}, $ \pk_\simulator  $ is an honest party's key. 
			
			%		During the simulation if $ \bdv $ sees $  k > |\ring_m| $-valid and malicious ring signatures $ \{\sigma_1, \sigma_2, \ldots,\sigma_k\} $ of the message $ m$ signed by $\ring $ whose anonymous keys are $ \{W_1, W_2, \ldots, W_k\} $, respectively , it runs $ \ext(\rsnark,..) $ for each valid malicious signatures $ \sigma_i $(signatures that are not generated by $ \bdv $) and obtains $ \openpk'_i, X'_i \in \ring $. In this case, the one of following two cases must happen:
			%		
			%		\begin{itemize}
				%			\item There exists $ X'\in \ring$ which is an honest key. In this case, $ \bdv  $ runs $ \pi_{eval} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \openpk$ and stores $ r V = x^*\genG + (\openpk - \openpk')K = x^*\genG + b K$ to $DB $. If $ DB $ is empty, rewind $ \adv $ to the beginning of the simulation. If it is not empty i.e., there exists $ \hat{r}X = \hat{\sk} \genG + \hat{b}K $, then $ \bdv $ first checks whether $ r = \hat{r} $. If it is the case, it aborts. If it is not the case, it finds the discrete logarithm of $ G=U $ on base $ K $ which is $ t = \frac{\hat{r}^{-1}\hat{b}^*-{r}^{-1}b}{{r}^{-1}\hat{\sk}-\hat{r}^{-1}\hat{\sk}} $.  Then, it outputs the CDH of $ U,V $ which is $ tV $. 
				%			We remark that $ \bdv $ aborts after rewinding with a negligible probability because it selects $ r $ randomly.
				%			%TODO exact probability
				%			\item  There exists $ X' \in \ring$ which is the  output of two different signatures.
				%		\end{itemize}
			%		
			%		
			%		During the simulation if $ \bdv $ sees a valid ring signature  $ m, \ring, \sigma = (\pi_{eval}, \pi_{ring}, C, W) $ where $ X = h^{-1}W \notin \ring$, then $ \bdv $ does the following: It runs the extractor algorithms on $ \pi_{ring} $ i.e., $ \ext(\rsnark,..) $ and obtains $ X' \in \ring $ and $ \openpk' $ where $ C = X' + \openpk' K $ and $ \pi_{eval} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \openpk$ where $ C = x\genG + \openpk K$ and $ W = x\hashG(m, \ring)= xhV$. In this case, $ X \neq X' $, so $ \openpk \neq \openpk' $. 
			%				  
			%				  
			%		\begin{itemize}
				%			\item If $ X' $ is honest, then store $ r V = x^*\genG + (\openpk - \openpk')K = x^*\genG + b K$ to $DB $. If $ DB $ is empty, rewind $ \adv $ to the beginning of the simulation. If it is not empty i.e., there exists $ \hat{r}X = \hat{\sk} \genG + \hat{b}K $, then $ \bdv $ first checks whether $ r = \hat{r} $. If it is the case, it aborts. If it is not the case, it finds the discrete logarithm of $ G=U $ on base $ K $ which is $ t = \frac{\hat{r}^{-1}\hat{b}^*-{r}^{-1}b}{{r}^{-1}\hat{\sk}-\hat{r}^{-1}\hat{\sk}} $.  Then, it outputs the CDH of $ U,V $ which is $ tV $. 
				%			We remark that $ \bdv $ aborts after rewinding with a negligible probability because it selects $ r $ randomly.
				%			%TODO exact probability
				%				  	
				%			\item If $ X' $ is  a malicious key, $ \bdv $ runs the extractor algorithm on PoK proof $ \pi_{dl} $ of $ X' $ i.e., $ \ext(\rdl,..,) $ which outputs $ x' $ where $ X' = x'G $. Since $ x' \neq x^* $, $ \bdv  $ has a Pedersen commitment $ C $ with two openings so it can find the discrete logarithm of $ K$ on base $ G $ which is $ t = \frac{x^* - x'}{\openpk' - \openpk^*} $.  In the end, it outputs the CDH of $ X,Y $ which is $ tU $. 
				%
				%		 \end{itemize}
			%		
			%	
			So, the probability of $ \bdv $ solves the CDH problem is equal to the probability of $ \adv $ breaks the forgery or uniqueness in the real protocol. Therefore,  if there exists $ \adv $ that makes $ \simulator$ aborts during the verification, then we can construct an adversary $ \bdv $ that solves the CDH problem except with a negligible probability.
			
			
				  
		\end{proof}
		This completes the security proof of our ring VRF protocol.\qed
	\end{proof}

