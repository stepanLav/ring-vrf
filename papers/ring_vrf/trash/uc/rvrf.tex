\section{A Ring VRF Construction without Secret Evaluation} 
\label{sec:ringvrfconstr}
Our ring VRF construction $\pvrf$ works in the $ \fcrs $-hybrid model described in Figure \ref{f:crs}. We need the common reference string (crs) in our scheme for SNARK proofs.
\begin{figure}
	\scriptsize
	\begin{tcolorbox}
		$ \fcrs $ is parametrized with the distribution $ \distribution $.
		{  \begin{description}
				\item [\textbf{CRS Generation:}] pick a value $ crs \sample \distribution $
				\item [\textbf{CRS Distribution:}] upon receiving the message $ (\msg{learn\-crs}, \sid) $, return the message $ (\msg{CRS}, \sid, crs) $.
			\end{description}
		}
	\end{tcolorbox}
	\caption{Functionality $\fcrs$.\label{f:crs}}
\end{figure}
We instantiate parameter generation by constructing a group $\GG$ in which discrete logarithm is hard, two generators $ G_1, G_2 \in  \GG$, and for which there exists a \textbf{s}uccinct
\textbf{n}on-interactive \textbf{ar}guments of \textbf{k}nowledge (SNARK) provides efficient proofs of elliptic curve arithmetic and efficient Merkle tree proofs.  We consider three hash functions: a hash-to-group function $\hashG : \{0,1\}^* \rightarrow \GG$ and $ \hash, \hash' : \{0,1\}^* \rightarrow \FF_p $. Our ring VRF construction works as follows:

\begin{itemize}
	\item $ \rvrf.\keygen(1^\kappa):  $ It selects randomly a secret key $ x \in \FF_p$ and computes the public key $ X = xG_1 $. It outputs $ \skrvrf = x $ and $ \pkrvrf = X $.
	\item $ \rvrf.\eval(\skrvrf, \pkring, m) $: It lets $ P = \hashG(m, \pkring) $ and computes $ W = xP  $. Then, it outputs $ y = \hash(m, \pkring, W) $. So, the VRF $ F $ in our protocol is $ F(\skvrf, \pkring, m) = H(m, \pkring, x\hashG(m,\pkring)) $.
	\item $ \rvrf.\evalprove(\skrvrf, \pkring, m) :$ It lets $ P = \hashG(m, \pkring) $ and computes $ W= xP, y = \hash(m, \pkring, W) $. The proving algorithm works as follows:
	\begin{itemize}
		\item It first commits its secret key $ \skvrf = x$ i.e., $ C = X + \beta G_2 $ where $ \beta \sample \FF_p $.
		\item It generates the first proof $ \pi_1 $ showing the following relation:
		$$\rel_1 = \{((x, \beta), (G_1, G_2, C,W,P)): C = xG_1 + \beta G_2, W = xP \}$$
		For this, it generates a non-interactive Schnorr proof with the Fiat-Shamir transform:  Sample random $r_1, r_2 \leftarrow \F_p$.
		Let $R = r_1 G_1 + r_2 G_2$, $R_m = r_1 P$, and
		$c = \hash'(\pkring, m, W,C,R,R_m)$.
		Set $\pi_1 = (c,s,\delta)$ where $s = r_1 - c x$ and $\delta = r_2 - c \beta$.
		\item It obtains $ crs $ from $ \fcrs $ for the second proof by sending the message $ (\msg{learncrs}, \sid) $ to $ \fcrs $. Then, it constructs a Merkle tree $ \mathsf{MT} $ of the public keys in $ \pkring $ whose root is denoted by $ \mathsf{root} $. In the end, it generates the second proof $ \pi_2 $ for the following relation with  the witness $ (\mathsf{copath}, x, \beta) $. 
		$$ \rel_2 = \{((\mathsf{copath}, x, \beta),(\mathsf{root}, C, G_1, G_2)): C-\beta G_2 = xG_1 = X, \mathsf{MT}.\verify(\mathsf{copath}, X, \mathsf{root} ) \rightarrow 1\} $$
		Here, $ \mathsf{copath} $ is a copath of the Merkle tree $ \mathsf{MT} $. $ \mathsf{MT}.\verify(\mathsf{copath}, X, \mathsf{root} ) $ is a verification algorithm of the Merkle tree which verifies whether $ X $ is the one of the leaves of $ \mathsf{MT} $ i.e., compute a root $ \mathsf{root}' $ with $ X $ and $ \mathsf{copath} $ and output 1 if $ \mathsf{root} = \mathsf{root}' $.
		
		The second proof $ \pi_2 $ is generated by running the proving algorithm of the SNARK i.e., $ \mathsf{SNARK}.\prove(\rel_2, crs,((\mathsf{root}, C, G_1, G_2)), (\mathsf{copath}, x, \beta)) $ \cite{groth16}.
	\end{itemize}
		In the end, $ \rvrf.\evalprove $ outputs $ y, \pi  $ where $ \pi = (\pi_1, \pi_2, C, W) $
	\item $ \rvrf.\verify(\pkring, m, y, \pi) $: It verifies the proofs $ \pi_1 $ and $ \pi_2 $.
	\begin{itemize}
		\item For the first proof $ \pi_1 = (c,s, \delta) $, it lets $R = s G_1 + \delta G_2 + c C$ and $R_m = s \hashG(m, \pkring) + c W$.
		Return true if $c = \hash'(\pkring,m,W,C,R,R_m)$.
		\item For the second proof $ \pi_2 $, it obtains $ crs $ from $ \fcrs $ by sending the message $ (\msg{learncrs}, \sid) $. Then, it constructs the Merkle tree $ \mathsf{MT} $ of the public keys $ \pkring $ and obtains $ \mathsf{root} $ which is the root of $ \mathsf{MT} $. In the end, it verifies $ \pi_2 $ by running the verification algorithm of the SNARK, i.e., $ \mathsf{SNARK}.\verify(\rel_2,crs, ((\mathsf{root}, C, G_1, G_2)), \pi_2) $.
	\end{itemize}
	If two of the verification algorithms output 1 and $ y =  \hash(m, \pkring,W)  $, $  \rvrf.\verify $ outputs 1. Otherwise, it outputs 0.
	\item $ \rvrf.\link(\skrvrf, \pkring, m, y,\pi): $ It generates a discrete logarithm equality proof $ \pi_{link} $ for the following relation:
	$$\rel_{dleq} = \{(x, (G_1, X,P,W)): X = xG_1, W = xP\}$$
	For this, it generates a non-interactive Schnorr proof with the Fiat-Shamir transform:  Pick $ r \sample \FF_p $ and let $ R = rG_1 $. Set $ c_\link = \hash'( \pkvrf,m,R,rP)) $ and $ s_\link = r_\link + cx $. In the end, it outputs the linking proof $ \pi_{link} = (c_\link,s_\link) $.
	\item $ \rvrf.\link\verify(\pkring, m, y, \pi, \pi_{link}) $: It obtains $ W $ from $ \pi $ and computes $ P = \hashG(m, \pkring) $. It outputs 1, if $ c = \hash'(\pkvrf,m, sG_1 - cX, sP-cW) $ and $ y = \hash(m, \pkring,W) $.
\end{itemize}


We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $-hybrid model and in the random oracle model under the assumption of the decisional Diffie Hellman (DDH) and Gap Diffie-Hellman (GDH) problems. The GDH problem is solving the computational DH problem by accessing the Diffie-Hellman oracle ($ \mathsf{DH}(.,.,.) $) which tells that given triple $ X,Y,Z $ is a DH-triple i.e., $ Z = xyG $ where $ X = xG $ and $ Y = yG $.

%\begin{definition}[$ n $-One-More Gap Diffie-Hellman (OM-GDH) problem]
%	Given   $ p $-order group $ \GG $ generated by $ G $, the challenges $ G, X = xG, P_1, P_2, \ldots, P_{n+1} $ and access to the DH oracle $ \mathsf{DH}(.,.,.) $ and the oracle $ \mathcal{O}_x(.) $ which returns $ xP $ given input $ P $, if a PPT adversary $ \mathcal{A} $ outputs $ xP_1, xP_2, \ldots, xP_{n+1} $ with the access of at most $ n $-times to the oracle $ \mathcal{O}_x $, then $ \mathcal{A}  $ solves the $ n $-OM-GDH problem. We say that $ n $-OM-GDH problem is hard in $ \GG $, if for all PPT adversaries, the probability of solving the $ n $-OM-GDH problem is negligible in terms of the security parameter.
%\end{definition}
\newcommand{\malkeys}{\mathsf{malicious}\_\vklist}
\newcommand{\hkeys}{\mathsf{honest}\_\vklist}
\begin{theorem}
	Assuming that $ \hashG, \hash, \hash' $ are random oracles, the GDH problem and the DDH problem is hard in the group structure $ (\GG, G_1, p) $ and SNARK is a zero-knowledge, $\pvrf$ UC-realizes $\fgvrf$ in the $\fcrs$-hybrid model according to Definition \ref{def:uc}.
\end{theorem}

\begin{proof}
	We construct a simulator $ \simulator $ that simulates the honest parties in the execution of $ \pvrf  $ and simulates the adversary in $ \fgvrf $. Moreover,
	$ \simulator $ behaves as $ \fcrs $ against the real world adversaries. 
	\begin{itemize}
		\item \textbf{[Simulation of $ \fcrs $:] }When simulating $ \fcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rel_2) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $. Whenever a party comes to learn the common reference string, $ \simulator $ gives $ crs $ as  $ \fcrs $.
		
		\item \textbf{[Simulation of $ \msg{keygen} $:]} Upon receiving $(\msg{keygen}, \sid, \user_i)$ from the functionality $\fgvrf$, $ \simulator $ samples $x \sample \FF_p$ and defines the key $X \defeq xG$. It adds $ xG $ to $ \hkeys $ and $ \vklist $ as a key of $ \user_i $. 
		In the end, $ \simulator $ returns $(\msg{verificationkey}, \sid, X)$ to $\fgvrf$. %Whenever the honest party $ \user $ is corrupted by $ \env, $ $ \simulator $ moves the key of $ \user $ to $ \malkeys $ from $ \hkeys $.
		
		\item\textbf{[Simulation of the random oracles:]} We  describe how $ \simulator $ simulates the random oracles $ \hashG, \hash $ and $ \hash' $ against the real world adversaries. 	$ \simulator $ simulates  $ \hash' $  as a usual random oracle.
		
		$ \simulator $ simulates the random oracle $ \hashG $ as described in Figure \ref{oracle:Hg}. In short, it selects a random element  $ h $ from $ \FF_p $ for each new input and outputs $ hG_1 $ as an output. Thus, $ \simulator $ knows the discrete logarithm of each random oracle output of $\hashG  $.
		\begin{figure}
			\centering
			
			\noindent\fbox{%
				\parbox{7cm}{%
					\underline{\textbf{Oracle $ \hashG $}} \\
					\textbf{Input:} $ m, \pkring $ \\
					\textbf{if} $\mathtt{oracle\_queries\_gg}[m, \pkring] = \perp  $
					
					\tab{$ h \sample \FF_p $}
					
					\tab{$ P \leftarrow hG_1 $} 
					
					\tab{$\mathtt{oracle\_queries\_gg}[m, \pkring] := h$}
					
					\textbf{else}:
					
					\tab{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $}
					
					\tab{$ P \leftarrow hG_1$}
					
					\textbf{return $ P $}
					
			}}	
			\caption{The random oracle $ \hashG $}
			\label{oracle:Hg}
		\end{figure}
	
		The simulation of the random oracle $ \hash $ is less straightforward (See Figure \ref{oracle:H}). Whenever an input $ m, \pkring, W $ is given to $ \hash $, it first obtains the discrete logarithm $ h $ of $ \hashG(m, \pkring) $ from the $ \hashG $'s database. It needs this information to detect whether $ W $ could be the value which is generated for the evaluation (See $ \rvrf.\eval $ in $ \pvrf $). Remark that if it is $ W $-value (pre-output) of the evaluation, it should be equal to $ x^*\hashG(m, \pkring)= x^*hG_1 $  where $ x^* \in \FF_p$ is a some ring VRF secret key. For this, it obtains $ X^* = h^{-1}W $. If $ X^* \in \pkring $, $ \simulator $ consider this oracle call as  a computation of evaluation of the  message $ m $ with the public key $ X^* $ and the ring $ \pkring $.
		If $ X^* $ has not been registered as a malicious key, it registers it to $ \fgvrf $. Thus, $ \simulator $ has a right to ask to evaluation of the message $ m $ to $ \fgvrf $. It asks the evaluation of the message $ m $ with the key $ X^* $ and the ring $ \pkring $ and learns $ y $ from $ \fgvrf $ which is the evaluation of $ m $. Then, it sets $ y $ as the answer of the random oracle $ \hash $  for the input $ m, \pkring, W $. If $ X^* $ is registered as an honest party's key and $ \hash(m,\pkring,W) $ is not defined before, $ \simulator $ aborts and the simulation ends.
		
		\begin{figure}
			\centering
			
			\noindent\fbox{%
				\parbox{11cm}{%
					\underline{\textbf{Oracle $ \hash$}} \\
					\textbf{Input:} $ m, \pkring,W $ \\			
					$ P \leftarrow \hashG(m,\pkring) $\\			
					$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $\\
					$ X^* := h^{-1}W $ // candidate key \\
					\textbf{if $ X^* \notin \pkring $} // it is not a evaluation query
					
					\tab{$ y \sample \FF_p $}
					
					\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
					
					\textbf{else:}
					
					\tab{\textbf{if} $ X^* \notin \vklist$// if the key has not been registered} 
					
					\tabdbl{\textbf{send} $ (\msg{keygen}, \sid, X^*) $ \textbf{to} $ \fgvrf $}
					
					\tabdbl{\textbf{add} $ X^* $ \textbf{to} $ \malkeys $ \textbf{and} $ \vklist $}
					
					\tab{\textbf{if} $ X^* \in \malkeys$}
					
					\tabdbl{\textbf{send} $ (\msg{eval}, \sid, \pkring, X^*, m) $ \textbf{to} $ \fgvrf $}
					
					\tabdbl{\textbf{receive} $ (\msg{evaluated}, \sid, \pkring, m, y) $ \textbf{from} $ \fgvrf $}
					
					\tabdbl{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
					
					\tab{\textbf{else if:} $ \mathtt{oracle\_queries\_h}[m, \pkring, W]  = \perp$}
					
					\tabdbl{\textbf{return} \textsc{Abort}}
					
					\textbf{return $  \mathtt{oracle\_queries\_h}[m, \pkring, W] $}
					
			}}	
			\caption{The random oracle $ \hash $}
			\label{oracle:H}
		\end{figure}
	
	\item \textbf{[Simulation of $ \msg{evalprove} $]} 
	%The simulator has table  $\preoutputlist $ to keep the pre-outputs that it selects for each input and the ring of public keys. 
	Upon receiving $(\msg{evalprove}, \sid, \pkring, m)$  from the functionality $\fgvrf$, $ \simulator $ generates the proof $ \pi $ as follows:
	
	For the first proof, it samples $ c, s, \delta \in \FF_p $ and $ C, W \in \GG$. Then, it lets the first proof be $\pi_1 =  (c, s, \delta) $. 
	In addition, it sets $ R = sG_1+ \delta G_2- cC $ and $ R_m = s \hashG(m, \pkring)+ cW $ and lets $ \pkring,m, W,C, R, R_m$ be $ c $ in the table of the random oracle $ \hash' $ so that $ \pi_1 $ verifies in the real-world execution.  
	%It adds $ W $ to the list $ \preoutputlist[m, \pkring] $.
	
	 $ \simulator $ gets the trapdoor $ \tau $ that it generated during the simulation of $ \fcrs $ to simulate the second proof. Then, it runs $ \mathsf{SNARK}.\mathsf{Simulate}(\rel_2,\tau, crs) $ and obtains $ \pi_2 $.
	 
	 In the end, $ \simulator $  responds by sending the message $(\msg{evalprove}, \sid, \pkring, m, \pi = (\pi_1, \pi_2, C, W))$ to the $ \fgvrf $. 
	\item \textbf{[Simulation of $ \msg{verifiy} $]} Upon receiving  $(\msg{verify}, \sid, \pkring, m, y, \pi)$ from the functionality $\fgvrf$,  it runs $ \rvrf.\verify(\pkring, m, y, \pi) \rightarrow b $. If there exists no $ m, \pkring, W $ such that $ \mathtt{oracle\_queries\_h}[m, \pkring, W] = y $ and  $ b = 1  $, $ \simulator $ aborts. Otherwise, it returns $ (\msg{verified}, \sid, \pkring, m, y, \pi, b) $ to  $\fgvrf  $.
%	\par\hrulefill
	\item \textbf{[Simulation of $ \msg{link} $:]} Upon receiving $(\msg{link}, \sid, \pkring, X_i, m, y, \pi)$ from $\fgvrf$, $ \simulator $ obtains $ W $ from $ \pi $. Remark that $ \simulator $ gave $ \pi $ to $ \fgvrf $, so $ W $ must be the part of $ \pi $. Then, it picks random $ s, c $ and lets $ (X_i, m, sG_1-cX_i, s\hashG(m, \pkring)- cW) $ be $ c $ in the table of the random oracle $ \hash' $. It sends $ (\msg{link}, \sid, X_i,(s,c)) $ to $ \fgvrf $. Also, if $ \hash(m,\pkring, W) $ is not defined, it sets $ \mathtt{oracle\_queries\_h}[m, \pkring, W] = y$. If it is defined but not equal to $ y $, it aborts.
	
	%TODO \item receiving $(\msg{verifylink}, \sid, \vk_i, R, m, y, \hat\pi)$, send $(\msg{verify}, \sid, (X, H, Y), m, \hat\pi)$ to $\fnizk$.
	\item \textbf{[Simulation of outputs of ideal honest parties:]} Whatever an honest party outputs in the ideal-world, $ \simulator $ outputs the same in the real-world simulation as an output of the same honest party. If the honest party's output is an evaluation value $ y $ and a proof $ \pi $ of an input $ m, \pkring $, $ \simulator $ checks whether the proof $ \pi $ of the evaluation $ y $ with the input $ m, \pkring $ is valid. For this,
	% it checks whether $ \prooflist[\pi] $ is assigned to an input $ m $ and a ring key set $ \pkring $. If it is the case, 
	it sends $ (\msg{verify}, \sid, \pkring, m, y, \pi) $ to $ \fgvrf $. If $ \fgvrf $ verifies it, $ \simulator $ retrieves $ W $ from $ \pi $ and sets $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ as $ y $ if $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ is not defined. $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ was already defined with another value, $ \simulator $ aborts. 
	\end{itemize}
	
	
	\begin{claim} 
		The view of $ \env $ in its interaction with the simulator $ \simulator $ is indistinguishable from the view in its interaction with real honest parties.
	\end{claim}
	
	\begin{proof}
		We prove this claim via a sequence of games. The initial game corresponds to the real protocol, whereas the final game corresponds to the simulator $\simulator$ described above. In each game, we change one (or more) step of in the ring VRF construction with the steps which are different in the simulation above.
		\begin{enumerate}[label={{Game} }{{\arabic*}}, start = 0]
		%\setlength\itemsep{0.1em}
			\item The simulator $ \simulator $ simulates the honest parties as in the ring VRF protocol that we describe in Section \ref{sec:ringvrfconstr}. 
			
			\item This game is the same as the previous game except that $ \simulator $ simulates the $ \fcrs $ functionality.  When simulating $ \fcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rel_2) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $ differently than the described $ \fcrs $ in Figure \ref{f:crs}. This game is indistinguishable from the previous game because 
			$ \mathsf{SNARK}.\mathsf{SetUp}(\rel_2) $ generates $ crs $ from the same distribution $ \distribution $. %TODO Is this true?
			
			\item This game is the same as in the previous game except that $ \simulator $ simulates the second proof of an input $ m, \pkring $ when running $ \evalprove $ by running  $ \mathsf{SNARK}.\mathsf{Simulate}(\rel_2, \tau, crs) $. Since SNARK has the zero-knowledge property, there exists a $ \mathsf{Simulate} $ algorithm which outputs a indistinguishable proof from the real proof. Therefore, this game is indistinguishable from the previous game.
			
			\item \label{game:roracles}This game is the same as in the previous game except that $ \simulator $ starts to simulate the random oracles  $ \hashG$  as described in Figure \ref{oracle:Hg}	and $ \hash' $ as a usual random oracle. Since $ \hashG $'s outputs are indistinguishable from a usual random oracle simulation of $ \hashG $, this game is same as the previous game.
			
			
			\item \label{game:DDH}This game is the same as the previous game except that $ \simulator $ simulates the first proof of an input $ m, \pkring $ when running $ \evalprove $ as follows: it samples $ c,s,\delta $ randomly from $ \FF_p $ and $ C, W \in \GG $. Then, it lets the first proof be $\pi_1 =  (c, s, \delta, C, W) $. 
			In addition, it sets $ R = sG_1+ \delta G_2- cC $ and $ R_m = s \hashG(m, \pkring)+ cW $ and lets $ \pkring,m, W,C, R, R_m$ be $ c $ in the table of the random oracle $ \hash' $. Since the discrete logarithm of $ W $'s generated for the first proofs are unknown to $ \simulator $ in this game, it simulates the link proof $ \pi_\link $ of an input $ \pkring, X_i, m, y, \pi $ as follows: it obtains $ W $ from $ \pi $ and picks random $ s_\link,c_\link \in \FF_p$ and sets $ X_i, m, s_\link G_1 - c_\link X_i, s\hashG(m,\pkring) - c_\link W$ to be $ c_\link $ in the table of the oracle $ \hash' $. Remark that $ s,\delta,C $ in $ \pi_1 $ and $ s_\link $ in $ \pi_\link $ are from the uniformly random distribution as in the previous game. Therefore, they are indistinguishable. However, $ W $ is not computed as $x \hashG(m, \pkring) $ as in the previous game. Therefore, we should show that selecting $ W $ randomly from $ \GG $ and computing $ W $ as $x \hashG(m, \pkring) $ are indistinguishable.
			We  show this under assumption that the decisional Diffie-Hellman (DDH) problem  is hard. We use the hybrid argument to show this.
			
			We define hybrid games $ H_{i} $ where $ \rvrf.\eval $ and $ \rvrf.\evalprove $ of the first $ i $ honest parties are computed as in the previous game and the rest are computed as in this game. Without loss of generality, $ \user_1, \user_2, \ldots, \user_{n_h} $ are the honest parties. Thus, $ H_0 $ is equivalent to \ref{game:DDH} and $ H_{n_h}  $ is equivalent to \ref{game:roracles}.  We construct an adversary $ \mathcal{B} $ that breaks the DDH problem given that there exists an adversary that distinguishes hybrid games $ H_i $ and $ H_{i + 1} $ for $ 0 \leq i < n_h $. $ \mathcal{B} $ receives the DDH challenges $ X,Y, Z \in \GG $ from the DDH game and simulates the game against $ \adv $ as follows: $ \mathcal{B} $ generates the public key of all  honest parties' key as usual by running $ \rvrf.\keygen$ except party $ \user_{i+1} $. It lets $ \user_{i+1} $'s public key be $ X $. Differently, it simulates the random oracle $ \hashG $ against $ \adv $ as described in Figure \ref{oracle:HgbyB}. Remark that this simulation is indistinguishable.
			
			\begin{figure}
				\centering
				
				\noindent\fbox{%
					\parbox{8cm}{%
						\underline{\textbf{Oracle $ \hashG $ in \ref{game:DDH} by the DDH adversary $ \mathcal{B} $}} \\
						\textbf{Input:} $ m, \pkring $ \\
						\textbf{if} $\mathtt{oracle\_queries\_gg}[m, \pkring] = \perp  $
						
						\tab{$ h \sample \FF_p $}
						
						\tab{\fbox{$ P \leftarrow hY $}}
						
						\tab{$\mathtt{oracle\_queries\_gg}[m, \pkring] := h$}
						
						\textbf{else}:
						
						\tab{\fbox{$ P \leftarrow hY $}}
						
						\textbf{return $ P $}
						
				}}	
				\caption{The simulation of the random oracle $ \hashG $ by $ \mathcal{B} $. The different steps than Figure \ref{oracle:Hg} are in the box.}
				\label{oracle:HgbyB}
			\end{figure}
			
			$ \mathcal{B} $ simulates the first $ i $ parties as in \ref{game:roracles} and the parties $ \user_{i+2}, \ldots, \user_q $ as in \ref{game:roracles}. The simulation of $ \user_{i + 1} $ is different. Whenever, $ \user_{i+1} $ needs to output evaluation of an input $ m, \pkring $, it obtains $ P = \hashG(m, \pkring) = hY $ from $ \mathtt{oracle\_queries\_gg} $, lets $ W = hZ $ and outputs $ \hash(m, \pkring, W) $. Remark that if $ (X,Y,Z)$ is a DH triple (i.e., $  \mathsf{DH}(X,Y,Z) \rightarrow 1 $), $ \user_{i+1} $ is simulated as in \ref{game:roracles} because $ W = xP $ in this case. Otherwise, $ \user_{i+1} $ is simulated as in \ref{game:DDH} because $ W $ is random. So, if $  \mathsf{DH}(X,Y,Z)  \rightarrow 1$, $ \mathcal{B} $ simulates $ H_{i+1} $. Otherwise, it simulates $ H_{i} $. In the end of the simulation, if $ \adv $ outputs $ i $, $ \mathcal{B} $ outputs $ 0 $ meaning $  \mathsf{DH}(X,Y,Z) \rightarrow 0$. Otherwise, it outputs $ i + 1 $. The success probability of $ \mathcal{B} $'s is equal to the success probability of $ \adv $ who distinguishes $ H_i $ and $ H_{i +1} $. Since DDH problem is hard, $ \mathcal{B} $ has negligible advantage in the DDH game. So, $ \adv $ has a negligible advantage too. Hence, from the hybrid argument, we can conclude that $ H_0  = $\ref{game:DDH} and $ H_q = $ \ref{game:roracles} are indistinguishable.
			
			
			
			\item \label{game:gdh}This game is the same as in the previous game except that $ \simulator $ starts to simulate the random oracle $ \hash $ as described in Figure \ref{oracle:Hgame}. We remark that the output of the simulation of $ \hash $ in this game and the output of the simulation of $ \hash $ in Figure \ref{oracle:H} are the same. The simulation of $ \hash $ in this game does not ask for the evaluation $ m, \pkring, W $ to $ \fgvrf $ for a malicious key $ X^* $ instead it picks the evaluation output randomly from $ \FF_p $. Since  $ \fgvrf $ also picks the evaluation output of $ m, \pkring, W $ from $ \FF_p $ randomly, this difference does not change the output distribution of the simulation of the random oracle $ \hash $ in Figure \ref{oracle:H} and $ \hash $ in Figure \ref{oracle:Hgame}.
			
				\begin{figure}
				\centering
				
				\noindent\fbox{%
					\parbox{8cm}{%
						\underline{\textbf{Oracle $ \hash$}} \\
						\textbf{Input:} $ m, \pkring,W $ \\			
						$ P \leftarrow \hashG(m,\pkring) $\\			
						$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $\\
						$ X^* := h^{-1}W $ // candidate key \\
						\textbf{if $ X^* \notin \pkring $}
						
						\tab{$ y \sample \FF_p $}
						
						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
						
						{\textbf{else if} $ X^* \in \malkeys$}
						
						\tab{$ y \sample \FF_p $}
						
						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
						
						{\textbf{else if} $ \mathtt{oracle\_queries\_h}[m, \pkring, W]  = \perp$}
						
						\tab{\textbf{return} \textsc{Abort}}
						
						\textbf{return $  \mathtt{oracle\_queries\_h}[m, \pkring, W] $}
						
				}}	
				\caption{The random oracle $ \hash $}
				\label{oracle:Hgame}
			\end{figure}
			
			The only difference from the simulation of $ \hash $ in this game from the random oracle $ \hash $ in the previous game is aborting when $ X^* $ belongs to an honest party and $  \mathtt{oracle\_queries\_h}[m, \pkring, W]  $ is not defined before. Therefore, we analyse the probability that the abort occurs during the simulation of $ \hash $ in this game. Intuitively, if the abort occurs, it means that the adversary obtained $ W = x^*P $ which has not been published by the honest party with the public key $ X^* $ because $ W $ is randomly selected instead of computing $ W = x^*P $ in this game. In a nutshell, we next show that if the adversary is able to obtain $ W = x^*P $, then we can construct another adversary $ \mathcal{B} $ that breaks the Gap-Diffie-Hellman (GDH) problem.
			
			Consider a GDH game in the group $ \GG $ with the generator $ G_1 $, challenges $ X, Y \in \GG$ and access to the Diffie-Hellman oracle $ \mathsf{DH} $. The GDH challenges are given to the adversary $ \mathcal{B} $ and $ \mathcal{B} $ starts to simulate \ref{game:gdh} to the adversary $ \adv $. The simulation is exactly the same except that $ \mathcal{B} $ picks a random $ r_x \in \ZZ_p $ and generates the public key of each party as $ r_xX $ and also simulates the random oracles $ \hash $ and $ \hashG $ differently as described in Figure \ref{oracle:HbyB} and Figure \ref{oracle:HgbyB}. Remark that $ \mathcal{B} $ in this game never needs to know the secret key of honest parties to simulate them since pre-outputs are selected randomly. Therefore, generating the honest public keys as this is indistinguishable. 			
			$ \mathcal{B} $ simulates the random oracle $ \hashG $ as described in Figure \ref{oracle:HgbyB}. In short, it generates the random group element by exponentiating the challenge $ Y $  instead of the generator $ G_1 $.  
			
			$ \mathcal{B} $ simulates the random oracle $ \hash $ as described in Figure \ref{oracle:HbyB}. The only difference from Figure \ref{oracle:Hgame} is the way of finding the candidate key if it exists. Remember that $ \hashG $ simulation is different. Therefore, when $ \mathcal{B} $ computes $ h^{-1}W $, it does not find a candidate key $ X^* $ if $ W $ is generated from one of the public keys in $ \pkring $ i.e., $ W = x^*\hashG(m, \pkring) $. The reason of this is if $ W $ is generated from one of the public keys in $ \pkring $, $X =  h^{-1}W = h^{-1} x^*\hashG(m, \pkring)  = x^*Y \neq X^*$. Therefore, $ \bdv $ gets advantage of having the access to $ \mathsf{DH} $ oracle to learn whether $ W $ is generated from one of the public keys in $ \pkring $ i.e., check whether $ \mathsf{DH}(X^*, Y, Z) \rightarrow 1$ for each $ X^* \in \pkring $. This step is indistinguishable from checking whether $ X^* = h^{-1}W $ in the simulation in Figure \ref{oracle:Hgame} because it does the same computation in a different way.
			
			\begin{figure}
				\centering
				
				\noindent\fbox{%
					\parbox{8cm}{%
						\underline{\textbf{Oracle $ \hash$}} \\
						\textbf{Input:} $ m, \pkring,W $ \\			
						$ P \leftarrow \hashG(m,\pkring) $\\			
						$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $
						\begin{mdframed}
							
							$ X^* := \mathsf{null} $
							
							$ Z := h^{-1}W $  
							
							\textbf{for $ X \in \pkring $}
							
							\tab{\textbf{if} $ \mathsf{DH}(X^*,Y,Z) \rightarrow 1 $}
							
							\tab{$ X^* := X $}
							
						\end{mdframed}
						\textbf{\textbf{if} $ X^* \notin \pkring $}
						
						\tab{$ y \sample \FF_p $}
						
						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
						
						{\textbf{else if} $ X^* \in \malkeys$}
						
						\tab{$ y \sample \FF_p $}
						
						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
						
						{\textbf{else if} $ \mathtt{oracle\_queries\_h}[m, \pkring, W]  = \perp$}
						
						\tab{\textbf{return} \textsc{Abort}}
						
						\textbf{return $  \mathtt{oracle\_queries\_h}[m, \pkring, W] $}
						
				}}	
				\caption{The simulation of the random oracle $ \hash $ by $ \mathcal{B} $. The different steps than Figure \ref{oracle:Hgame} are in the box.}
				\label{oracle:HbyB}
			\end{figure}
			
			If $ \mathcal{B} $ aborts during the simulation of $ \hash $, it means that $ X^* $ belongs to an honest party and $ DH(X^*,Y,Z) \leftarrow 1 $. We know the honest public key $ X^* $ is generated as $ r^*X $ for $ r^* \in \FF_p $. Therefore, $ (r^*)^{-1}Z $ is the CDH solution of $ X,Y $. This shows that if the probability of abort in the random oracle $ \hash $ is equal to the probability of solving the GDH problem. Therefore, \ref{game:gdh} and \ref{game:DDH} are indistinguishable.
			
%			Consider the one-more GDH game in the group $ \GG $ with the generator $ G_1 $, challenges $ X = xG_1, P_1, P_2, \ldots, P_{q_{h_g}} \in \GG$ and access to the Diffie-Hellman oracle $ \mathsf{DH}(.,.,.) $ and the oracle  $\mathcal{O}_x(.) $ which returns $ xP $ given $ P $. The OM-GDH challenges are given to the adversary $ \mathcal{B} $ and $ \mathcal{B} $ starts to simulate the Game 3 to the adversary $ \adv $. The simulation is exactly the same except that $ \mathcal{B} $ picks a random $ r_i \in \ZZ_p $ and generates the public key of each party as $ X_i = r_iX $. In this case, $ \mathcal{B} $ does not know the corresponding secret keys. Therefore, when it needs to run the evaluation, it obtains the pre-output value of the given input $ \pkring,m $ and public key $ X_i $ by asking $ \mathcal{O}_x(.) $ with the input $ P $ where $ P = \hashG(m, \pkring) $ and lets the pre-output be $ W = r_i\mathcal{O}_x(P) $ (See Figure \ref{sim:preoutputs}).  Since $ n_e \leq q_h $, $ \mathcal{B} $ has enough source to compute the pre-outputs. 
%			
%			
%			\begin{figure}
%				\centering
%				
%				\noindent\fbox{%
%					\parbox{5cm}{%
%						\underline{\textbf{Computation of  pre-outputs}} \\
%							\textbf{Input:} $ X_i, m, \pkring $ 
%							
%							$ P := \hashG(m, \pkring) $
%							
%							\textbf{if}   $ \lst[P] = \perp $
%							
%							\tab{$ Q \leftarrow \mathcal{O}_x(P) $}
%							
%							\tab{$ \lst[P] := Q $}
%							
%							\textbf{else}:
%							
%							\tab{$ Q := \lst[P] $}
%							
%							\textbf{return $ r_iQ $}
%							
%					}}	
%					\caption{The simulation of pre-outputs by $ \mathcal{B} $. }
%					\label{sim:preoutputs}
%				\end{figure}
%			
%			
%			
%			Besides, $ \mathcal{B} $ simulates the random oracles $ \hash $ and $ \hashG $ differently as described in Figure \ref{oracle:HbyB} and Figure \ref{oracle:HgbyB}.  
%			
%			The simulation of the random oracle $ \hashG $, $ \bdv $ returns $ P_i $ (one of the OM-GDH challenge). Since $ P_1, P_2, \ldots, P_{q_{h_g}} $ are generated randomly. the new simulation of $ \hashG $ is indistinguishable from the simulation in Game 3 (Figure \ref{oracle:Hg}).
%			
%			\begin{figure}
%				\centering
%				
%				\noindent\fbox{%
%					\parbox{8cm}{%
%						\underline{\textbf{Oracle $ \hashG $ in Game 2 by the CDH adversary $ \mathcal{B} $}} \\
%						\textbf{Input:} $ m, \pkring $ 
%						
%						$ \ell := \ell + 1 $
%						
%						\textbf{if} $\mathtt{oracle\_queries\_gg}[m, \pkring] = \perp  $
%						  
%						\tab{\fbox{$ P \leftarrow P_\ell $}}
%						
%						\tab{$\mathtt{oracle\_queries\_gg}[m, \pkring] := P$}
%						
%						\textbf{else}:
%						
%						\tab{\fbox{$ P \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $}}
%						
%						\textbf{return $ P $}
%						
%				}}	
%				\caption{The simulation of the random oracle $ \hashG $ by $ \mathcal{B} $. The different steps than Figure \ref{oracle:Hg} are in the box.}
%				\label{oracle:HgbyB}
%			\end{figure}
%			
%			$ \mathcal{B} $ simulates the random oracle $ \hash $ as described in Figure \ref{oracle:HbyB}. The only difference is the way of finding out whether the query is possibly done for the evaluation. Remember that $ \hashG $ is simulated differently by $ \mathcal{B} $. 
%			Therefore, computing $ h^{-1}W $ does not work in this simulation to deduce the candidate key because $ h $ which is the discrete logarithm of $ \hashG(m, \pkring) $ is not known. Instead, $ \bdv $ gets advantage of having the access to $ \mathsf{DH} $ oracle to learn whether $ W $ is generated from one of the public keys in $ \pkring $ i.e., check whether $ \mathsf{DH}(X^*, P, W) \rightarrow 1$ for each $ X^* \in \pkring $ where $ P = \hashG(m, \pkring) $. This step is indistinguishable from checking whether $ X^* = h^{-1}W $ in the simulation in Figure \ref{oracle:Hgame} because it does the same computation.
%			
%			
%			%, it does not find a candidate key $ X^* $ if $ W $ is generated from one of the public keys in $ \pkring $ i.e., $ W = x^*\hashG(m, \pkring) $. The reason of this, if $ W $ is generated from one of the public keys in $ \pkring $, $X =  h^{-1}W = h^{-1} x^*\hashG(m, \pkring)  = x^*Y \neq X^*$. Therefore, $ \bdv $ gets advantage of having the access to $ \mathsf{DH} $ oracle to learn whether $ W $ is generated from one of the public keys in $ \pkring $ i.e., check whether $ \mathsf{DH}(X^*, Y, Z) \rightarrow 1$ for each $ X^* \in \pkring $. This step is indistinguishable from checking whether $ X^* = h^{-1}W $ in the simulation in Figure \ref{oracle:Hgame}.
%				
%				\begin{figure}[h]
%				\centering
%				
%				\noindent\fbox{%
%					\parbox{8cm}{%
%						\underline{\textbf{Oracle $ \hash$}} \\
%						\textbf{Input:} $ m, \pkring,W $ \\			
%						$ P \leftarrow \hashG(m,\pkring) $\\			
%						\sout{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $}
%						\begin{mdframed}
%						
%						$ X^* := \mathsf{null} $
%						
%						%$ Z := h^{-1}W $  
%					
%						\textbf{for $ X \in \pkring $}
%						
%						\tab{\textbf{if} $ \mathsf{DH}(X^*,P,W) \rightarrow 1 $}
%						
%						\tab{$ X^* := X $}
%						
%					   \end{mdframed}
%						\textbf{\textbf{if} $ X^* \notin \pkring $}
%						
%						\tab{$ y \sample \FF_p $}
%						
%						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
%						
%						{\textbf{else if} $ X^* \in \malkeys$}
%						
%						\tab{$ y \sample \FF_p $}
%						
%						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
%						
%						{\textbf{else if} $ \mathtt{oracle\_queries\_h}[m, \pkring, W]  = \perp$}
%						
%						\tab{\textbf{return} \textsc{Abort}}
%						
%						\textbf{return $  \mathtt{oracle\_queries\_h}[m, \pkring, W] $}
%						
%				}}	
%				\caption{The simulation of the random oracle $ \hash $ by $ \mathcal{B} $. The removed steps are crossed out. The different steps than Figure \ref{oracle:Hgame} are in the box.}
%				\label{oracle:HbyB}
%			\end{figure}
%		
%			If $ \mathcal{B} $ aborts during the simulation of $ \hash $, it means that $ \mathcal{A} $ obtained $ W $ before the honest party with the public key $ X^* $ runs the evaluation algorithm. Given that $ \mathcal{B} $ runs the evaluation at most $ n_e \leq  q_{h_g} $ times, if abort occurs during the simulation of $ \hash $, the number of evaluations is when the abort occurs at most $ q_{h_g} - 1$. The reason of this, if $ n_e = q_{h_g} $, it means that all  $ \hashG $ queries are used up by $ \mathcal{B} $ for number of  $ n_e = q_{h_g} $ evaluations and so the abort case in the simulation of $ \hash $ cannot occur. Therefore, when  abort occurs in $ \hash $, it means that $ n_e \leq q_{h_g} - 1 $.  In the end, $ \mathcal{B} $ outputs $ \{\lst{P}\}_{P \in \setsym{C}} $ to the OM-GDH game. The success probability of $ \mathcal{B} $ solving the OM-GDH problem is equal to the probability that abort occurs in $ \hash $. So, the probability of abortion during the simulation of $ \hash $ in this game is negligible.
			
			\item This game is the same as the previous game except that if $ \simulator $ receives evaluation and proof $ y, \pi $ for the input $ m, \pkring $, but $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ where $ W \in \pi $ is not defined and $ \rvrf.\verify(\pkring, m, y, \pi) \rightarrow 1$, $ \simulator $ aborts. If $ \rvrf.\verify(\pkring, m, y, \pi) \rightarrow 1$,  $ y = \hash(m, \pkring,W) $. So, it means that $ \adv $ guessed the output of $ \hash(m, \pkring,W) $ without asking the random oracle $ \hash $. Since the probability that it happens is negligible, this game is indistinguishable from the previous game.
			
%			Simulation verify is indistinguishable because the only way for the environment to learn $ y $ is asking the evaluation of the $ m, \pkring $ from the adversary. The adversary can learn it from the random oracle. This game guarantees that the evaluation is stored in the random oracle $ \hash $'s database 
			The last game is exactly the same as the simulator that we described for $ \fgvrf $. This shows that the simulator $ \simulator $ that we describe for $ \fgvrf $ is indistinguishable from the real protocol. So, the environment $ \env $ cannot distinguish the real-world simulation from the real protocol except with a negligible probability. 
				
		
		\end{enumerate}
	\qed
	\end{proof}	

	\begin{claim}
		The distributions of the outputs of honest and malicious parties in ideal and real worlds are indistinguishable.
	\end{claim}
	$ \simulator $ outputs whatever the honest parties output in the ideal-world. 
	Therefore, the output of the honest parties are identical. While outputting them, it updates the random oracles respectively so that the verification process of these outputs (either $ \rvrf.\verify $ or $ \rvrf.\link\verify $) verifies in the real protocol. The cases where $ \simulator $ aborts happens if corresponding random oracle input is already assigned to another value which can happen with a negligible probability. Therefore, the outputs in the real and ideal world are indistinguishable.
	
\qed
\end{proof}
