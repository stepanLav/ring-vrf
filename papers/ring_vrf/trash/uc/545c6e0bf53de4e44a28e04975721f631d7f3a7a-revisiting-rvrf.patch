From 545c6e0bf53de4e44a28e04975721f631d7f3a7a Mon Sep 17 00:00:00 2001
From: Handan Kilinc <handankilinc1@gmail.com>
Date: Fri, 27 Aug 2021 17:21:20 +0200
Subject: [PATCH 001/125] revisiting rvrf

---
 papers/rvrf/main.tex               |  37 ++--
 papers/rvrf/model.tex              |  51 ++---
 papers/rvrf/rvrf.tex               | 333 +++++++++++++++--------------
 papers/rvrf/rvrf_functionality.tex |  23 +-
 4 files changed, 224 insertions(+), 220 deletions(-)

diff --git a/papers/rvrf/main.tex b/papers/rvrf/main.tex
index 15a72a5..f7e7755 100644
--- a/papers/rvrf/main.tex
+++ b/papers/rvrf/main.tex
@@ -162,23 +162,24 @@ sets
 \date{}
 \begin{document}
 	
-\maketitle
+	\maketitle
+	
+	\begin{abstract}
+	\end{abstract}
+	
+	
+	\input{model}
+	\input{rvrf}
+	
+	
+	%\input{rvrf_se}	
+	
+	
+	
+	
+	
+	\bibliographystyle{plain}
+	\bibliography{references}
+	
 	
-\begin{abstract}
-\end{abstract}
-
-
-\input{model}
-\input{rvrf}
-
-\input{rvrf_se}	
-
-
-
-
-
-\bibliographystyle{plain}
-\bibliography{references}
-
-
 \end{document}
diff --git a/papers/rvrf/model.tex b/papers/rvrf/model.tex
index a5ae2ae..b44e3ac 100644
--- a/papers/rvrf/model.tex
+++ b/papers/rvrf/model.tex
@@ -1,45 +1,46 @@
 \section{Security Model of Ring VRF}
 
 
-In this section, we describe the security of our new cryptographic primitive ring VRF. First, we describe the basic ring VRF in the real world and in the ideal world. Second, we extend the basic ring VRF by adding a new property that we call secret evaluation. 
+In this section, we describe the security of our new cryptographic primitive ring VRF. We describe the  ring VRF in the real world and in the ideal world. 
 
 
-\paragraph{Ring VRF (Basic Definition):} A ring VRF operates like a VRF but only proves its key comes from a specific list without giving any information about which specific key. We define the ring VRF functionality $ \fgvrf $ in Figure \ref{f:gvrf}. The functionality lets parties generate a key (Key Generation), evaluate a message with the party's key (VRF Evaluation), prove that the evaluation is executed by one of the keys (VRF evaluation and proof) and verify the evaluation without knowing the key used for the evaluation (Verification). We also define linking procedures in $ \fgvrf $ to link an evaluation and a proof with its associated key. So, if a party wants to reveal its identity at some point, it can use the linking process to prove that the evaluation is executed with its key (Linking proof). Later on, anyone can verify the linking proof (Linking verification).
+\paragraph{Ring VRF:} A ring VRF operates like a VRF but only proves its key comes from a specific list without giving any information about which specific key. We define the ring VRF functionality $ \fgvrf $ in Figure \ref{f:gvrf}. The functionality lets parties generate a key (Key Generation), evaluate a message with the party's key (VRF Evaluation), prove that the evaluation is executed by one of the keys (VRF evaluation and proof) and verify the evaluation without knowing the key used for the evaluation (Verification). We also define linking procedures in $ \fgvrf $ to link an evaluation and a proof with its associated key. So, if a party wants to reveal its identity at some point, it can use the linking process to prove that the evaluation is executed with its key (Linking proof). Later on, anyone can verify the linking proof (Linking verification).
 %TODO Secret Evaluation
 \input{rvrf_functionality}
-In a nutshell, the functionality $\fgvrf$, when given as input a message $m$ and a key set $\pkring$ of participant, allows to create $n$ possible different outputs pseudo-random that appear independent from the inputs. The output can be verified to have been computed correctly by one of the participants in $\pkring$ without revealing who they are. At a later stage, the author of the VRF output can prove that the output was generated by them and no other participant could have done so.
+
+In a nutshell, the functionality $\fgvrf$, when given as input a message $m$ and a key set $\pkring$ of participant, allows to create $n$ possible different outputs pseudo-random that appear independent from the inputs. The output can be verified to have been computed correctly by one of the participants in $\pkring$ without revealing who they are. At a later stage, the author of the VRF output can prove that the output was generated by him and no other participant could have done so.
 
 Below, we define the real-world execution of the ring VRF.
 \begin{definition}[Ring-VRF (rVRF)]\label{def:ringvrf}
-	Ring VRF is a VRF with a deterministic function $ F(.,.):\{0,1\}^\kappa \times\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $ and with the following algorithms:
+	A ring VRF is a VRF with a deterministic function $ F(.,.):\{0,1\}^\kappa \times\{0,1\}^{\ell_m} \rightarrow \{0,1\}^{\ell_\rvrf} $ and with the following algorithms:
 	
 	\begin{itemize}
 		\item $ \rvrf.\keygen(1^\kappa) \rightarrow (\skrvrf,\pkrvrf)$ where $ \kappa $ is the security parameter,
 	\end{itemize}
-	Given list of public keys $ \pkring = \set{\pkrvrf_1, \pkrvrf_2, \ldots, \pkrvrf_n}$, a message $ m \in \{0,1\}^* $
+	Given list of public keys $ \pkring = \set{\pkrvrf_1, \pkrvrf_2, \ldots, \pkrvrf_n}$, a message $ m \in \{0,1\}^{\ell_m} $
 	\begin{itemize}
 		\item $ \rvrf.\eval(\skrvrf_i, \pkring, m)\rightarrow y $ where $ y = F(\skrvrf,\pkring,m) $,
-		\item $ \rvrf.\evalprove(\skrvrf_i, \pkring, m)\rightarrow (F(\skrvrf,\pkring,m),\pi) $ where  $ \pi $ is a proof for the evaluation.
+		\item $ \rvrf.\prove(\skrvrf_i, \pkring, m)\rightarrow (F(\skrvrf,\pkring,m),\pi) $ where  $ \pi $ is a proof for the evaluation.
 		\item $ \rvrf.\verify(\pkring, m, y,\pi) \rightarrow  b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
-		\item $ \rvrf.\link(\skrvrf_i, \pkring,m,y, \pi) \rightarrow \pi_{\link} $ where  $ \pi^\link $ is a proof linking the public key of the producer of $ y $. 
-		\item $ \rvrf.\link\verify(\pkring, \skrvrf_i, m, y, \pi,, \pi_{\link})\rightarrow b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
+		\item $ \rvrf.\link(\skrvrf_i, \pkring,m,y, \pi) \rightarrow \pi_{\link} $ where  $ \pi_\link $ is a proof linking the public key of $ y $'s  producer. 
+		\item $ \rvrf.\link\verify( \pkrvrf_i,\pkring, m, y, \pi, \pi_{\link})\rightarrow b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
 	\end{itemize}
 	
 \end{definition}
-\paragraph{Ring VRF with Secret Evaluation:} 
-
-
-Below, we define the real-world execution of the ring VRF with secret evaluation.
-\begin{definition}[Ring-VRF (rVRF)]\label{def:ringvrfse}
-	Ring VRF with secret evaluation is two VRFs with a deterministic function $ F(.,.):\{0,1\}^\kappa \times\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $ and$ F_s(.,.):\{0,1\}^\kappa \times\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $. It consists of the algorithms of ring VRF defined in Definition \ref{def:ringvrf} and additionally the following algorithms:
-	
-	Given list of public keys $ \pkring = \set{\pkrvrf_1, \pkrvrf_2, \ldots, \pkrvrf_n}$, a message $ m \in \{0,1\}^* $
-	\begin{itemize}
-		\item $ \rvrf.\secreteval(\skrvrf_i, \pkring, m)\rightarrow \omega $ where $ \omega = F_s(\skrvrf,\pkring,m) $,
-		\item $ \rvrf.\secretprove(\skrvrf_i, \pkring, m)\rightarrow \pi / \perp $ where  $ \pi $ is a proof for the secret evaluation. If $ (F_s(\skrvrf,\pkring,m), (\pkring, m)) \notin \rel  $, it outputs $ \perp $.
-		\item $ \rvrf.\secretverify(\pkring, m,\pi) \rightarrow  b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
-	\end{itemize}
-	
-\end{definition}
-
-\input{rvrf_se_functionality}
\ No newline at end of file
+%\paragraph{Ring VRF with Secret Evaluation:} 
+%
+%
+%Below, we define the real-world execution of the ring VRF with secret evaluation.
+%\begin{definition}[Ring-VRF (rVRF)]\label{def:ringvrfse}
+%	Ring VRF with secret evaluation is two VRFs with a deterministic function $ F(.,.):\{0,1\}^\kappa \times\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $ and$ F_s(.,.):\{0,1\}^\kappa \times\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $. It consists of the algorithms of ring VRF defined in Definition \ref{def:ringvrf} and additionally the following algorithms:
+%	
+%	Given list of public keys $ \pkring = \set{\pkrvrf_1, \pkrvrf_2, \ldots, \pkrvrf_n}$, a message $ m \in \{0,1\}^* $
+%	\begin{itemize}
+%		\item $ \rvrf.\secreteval(\skrvrf_i, \pkring, m)\rightarrow \omega $ where $ \omega = F_s(\skrvrf,\pkring,m) $,
+%		\item $ \rvrf.\secretprove(\skrvrf_i, \pkring, m)\rightarrow \pi / \perp $ where  $ \pi $ is a proof for the secret evaluation. If $ (F_s(\skrvrf,\pkring,m), (\pkring, m)) \notin \rel  $, it outputs $ \perp $.
+%		\item $ \rvrf.\secretverify(\pkring, m,\pi) \rightarrow  b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
+%	\end{itemize}
+%	
+%\end{definition}
+%
+%\input{rvrf_se_functionality}
\ No newline at end of file
diff --git a/papers/rvrf/rvrf.tex b/papers/rvrf/rvrf.tex
index 7c41959..95ab295 100644
--- a/papers/rvrf/rvrf.tex
+++ b/papers/rvrf/rvrf.tex
@@ -1,4 +1,4 @@
-\section{A Ring VRF Construction without Secret Evaluation} 
+\section{Our Ring VRF Construction } 
 \label{sec:ringvrfconstr}
 Our ring VRF construction $\pvrf$ works in the $ \fcrs $-hybrid model described in Figure \ref{f:crs}. We need the common reference string (crs) in our scheme for SNARK proofs.
 \begin{figure}
@@ -13,15 +13,16 @@ Our ring VRF construction $\pvrf$ works in the $ \fcrs $-hybrid model described
 	\end{tcolorbox}
 	\caption{Functionality $\fcrs$.\label{f:crs}}
 \end{figure}
-We instantiate parameter generation by constructing a group $\GG$ in which discrete logarithm is hard, two generators $ G_1, G_2 \in  \GG$, and for which there exists a \textbf{s}uccinct
+We instantiate parameter generation by constructing a group $\GG$ of order $ p $ in which discrete logarithm is hard, two generators $ G_1, G_2 \in  \GG$, and for which there exists a \textbf{s}uccinct
 \textbf{n}on-interactive \textbf{ar}guments of \textbf{k}nowledge (SNARK) provides efficient proofs of elliptic curve arithmetic and efficient Merkle tree proofs.  We consider three hash functions: a hash-to-group function $\hashG : \{0,1\}^* \rightarrow \GG$ and $ \hash, \hash' : \{0,1\}^* \rightarrow \FF_p $. Our ring VRF construction works as follows:
 
 \begin{itemize}
 	\item $ \rvrf.\keygen(1^\kappa):  $ It selects randomly a secret key $ x \in \FF_p$ and computes the public key $ X = xG_1 $. It outputs $ \skrvrf = x $ and $ \pkrvrf = X $.
-	\item $ \rvrf.\eval(\skrvrf, \pkring, m) $: It lets $ P = \hashG(m, \pkring) $ and computes $ W = xP  $. Then, it outputs $ y = \hash(m, \pkring, W) $. So, the VRF $ F $ in our protocol is $ F(\skvrf, \pkring, m) = H(m, \pkring, x\hashG(m,\pkring)) $.
-	\item $ \rvrf.\evalprove(\skrvrf, \pkring, m) :$ It lets $ P = \hashG(m, \pkring) $ and computes $ W= xP, y = \hash(m, \pkring, W) $. The proving algorithm works as follows:
+	\item $ \rvrf.\eval(\skrvrf, \pkring, m) $: It lets $ P = \hashG(m, \pkring) $ and computes $ W = xP  $. Then, it outputs $ y = \hash(m, \pkring, W) $. So, the deterministic function $ F $ in our rVRF protocol is $ F(\skvrf, \pkring, m) = H(m, \pkring, x\hashG(m,\pkring)) $.
+	\item $ \rvrf.\prove(\skrvrf, \pkring, m) :$ It lets $ P = \hashG(m, \pkring) $ and computes $ W= xP, y = \hash(m, \pkring, W) $. The proving algorithm works as follows:
 	\begin{itemize}
-		\item It first commits its secret key $ \skvrf = x$ i.e., $ C = X + \beta G_2 $ where $ \beta \sample \FF_p $.
+		\item It first commits its secret key $
+		x$ i.e., $ C = X + \beta G_2 $ where $ \beta \sample \FF_p $.
 		\item It generates the first proof $ \pi_1 $ showing the following relation:
 		$$\rel_1 = \{((x, \beta), (G_1, G_2, C,W,P)): C = xG_1 + \beta G_2, W = xP \}$$
 		For this, it generates a non-interactive Schnorr proof with the Fiat-Shamir transform:  Sample random $r_1, r_2 \leftarrow \F_p$.
@@ -34,22 +35,22 @@ We instantiate parameter generation by constructing a group $\GG$ in which discr
 		
 		The second proof $ \pi_2 $ is generated by running the proving algorithm of the SNARK i.e., $ \mathsf{SNARK}.\prove(\rel_2, crs,((\mathsf{root}, C, G_1, G_2)), (\mathsf{copath}, x, \beta)) $ \cite{groth16}.
 	\end{itemize}
-		In the end, $ \rvrf.\evalprove $ outputs $ y, \pi  $ where $ \pi = (\pi_1, \pi_2, C, W) $
+	In the end, $ \rvrf.\prove $ outputs $ y, \pi  $ where $ \pi = (\pi_1, \pi_2, C, W) $
 	\item $ \rvrf.\verify(\pkring, m, y, \pi) $: It verifies the proofs $ \pi_1 $ and $ \pi_2 $.
 	\begin{itemize}
-		\item For the first proof $ \pi_1 = (c,s, \delta) $, it lets $R = s G_1 + \delta G_2 + c C$ and $R_m = s \hashG(m, \pkring) + c W$.
-		Return true if $c = \hash'(\pkring,m,W,C,R,R_m)$.
+		\item For the first proof $ \pi_1 = (c,s, \delta) $, it lets $R' = s G_1 + \delta G_2 + c C$ and $R'_m = s \hashG(m, \pkring) + c W$. It
+		returns true if $c = \hash'(\pkring,m,W,C,R',R'_m)$.
 		\item For the second proof $ \pi_2 $, it obtains $ crs $ from $ \fcrs $ by sending the message $ (\msg{learncrs}, \sid) $. Then, it constructs the Merkle tree $ \mathsf{MT} $ of the public keys $ \pkring $ and obtains $ \mathsf{root} $ which is the root of $ \mathsf{MT} $. In the end, it verifies $ \pi_2 $ by running the verification algorithm of the SNARK, i.e., $ \mathsf{SNARK}.\verify(\rel_2,crs, ((\mathsf{root}, C, G_1, G_2)), \pi_2) $.
 	\end{itemize}
 	If two of the verification algorithms output 1 and $ y =  \hash(m, \pkring,W)  $, $  \rvrf.\verify $ outputs 1. Otherwise, it outputs 0.
-	\item $ \rvrf.\link(\skrvrf, \pkring, m, y,\pi): $ It generates a discrete logarithm equality proof $ \pi_{link} $ for the following relation:
+	\item $ \rvrf.\link(\skrvrf, \pkring, m, y,\pi): $ It generates a discrete logarithm equality proof $ \pi_{\link} $ for the following relation:
 	$$\rel_{dleq} = \{(x, (G_1, X,P,W)): X = xG_1, W = xP\}$$
-	For this, it generates a non-interactive Schnorr proof with the Fiat-Shamir transform:  Pick $ r \sample \FF_p $ and let $ R = rG_1 $. Set $ c_\link = \hash'( \pkvrf,m,R,rP)) $ and $ s_\link = r_\link + cx $. In the end, it outputs the linking proof $ \pi_{link} = (c_\link,s_\link) $.
-	\item $ \rvrf.\link\verify(\pkring, m, y, \pi, \pi_{link}) $: It obtains $ W $ from $ \pi $ and computes $ P = \hashG(m, \pkring) $. It outputs 1, if $ c = \hash'(\pkvrf,m, sG_1 - cX, sP-cW) $ and $ y = \hash(m, \pkring,W) $.
+	For this, it generates a non-interactive Schnorr proof with the Fiat-Shamir transform:  Pick $ r_\link \sample \FF_p $ and let $ R = r_\link G_1 $. Set $ c_\link = \hash'( X,m,R,r_\link P) $ and $ s_\link = r_\link + c_\link x $. In the end, it outputs the linking proof $ \pi_{\link} = (c_\link,s_\link) $.
+	\item $ \rvrf.\link\verify(\pkrvrf,\pkring, m, y, \pi, \pi_{\link}) $: It obtains $ W $ from $ \pi $ and computes $ P = \hashG(m, \pkring) $. It outputs 1, if $ c_\link = \hash'(\pkrvrf,m, sG_1 - cX, sP-cW) $ and $ y = \hash(m, \pkring,W) $.
 \end{itemize}
 
 
-We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $-hybrid model and in the random oracle model under the assumption of the decisional Diffie Hellman (DDH) and Gap Diffie-Hellman (GDH) problems. The GDH problem is solving the computational DH problem by accessing the Diffie-Hellman oracle ($ \mathsf{DH}(.,.,.) $) which tells that given triple $ X,Y,Z $ is a DH-triple i.e., $ Z = xyG $ where $ X = xG $ and $ Y = yG $.
+We next show that our ring VRF $ \pvrf $ construction realizes $ \fgvrf $ in the $ \fcrs $-hybrid model and in the random oracle model under the assumption of the hardness of the decisional Diffie Hellman (DDH) and Gap Diffie-Hellman (GDH) problems. The GDH problem is solving the computational DH problem by accessing the Diffie-Hellman oracle ($ \mathsf{DH}(.,.,.) $) which tells that given triple $ X,Y,Z $ is a DH-triple i.e., $ Z = xyG $ where $ X = xG $ and $ Y = yG $.
 
 %\begin{definition}[$ n $-One-More Gap Diffie-Hellman (OM-GDH) problem]
 %	Given   $ p $-order group $ \GG $ generated by $ G $, the challenges $ G, X = xG, P_1, P_2, \ldots, P_{n+1} $ and access to the DH oracle $ \mathsf{DH}(.,.,.) $ and the oracle $ \mathcal{O}_x(.) $ which returns $ xP $ given input $ P $, if a PPT adversary $ \mathcal{A} $ outputs $ xP_1, xP_2, \ldots, xP_{n+1} $ with the access of at most $ n $-times to the oracle $ \mathcal{O}_x $, then $ \mathcal{A}  $ solves the $ n $-OM-GDH problem. We say that $ n $-OM-GDH problem is hard in $ \GG $, if for all PPT adversaries, the probability of solving the $ n $-OM-GDH problem is negligible in terms of the security parameter.
@@ -62,16 +63,16 @@ We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $
 
 \begin{proof}
 	We construct a simulator $ \simulator $ that simulates the honest parties in the execution of $ \pvrf  $ and simulates the adversary in $ \fgvrf $. Moreover,
-	$ \simulator $ behaves as $ \fcrs $ against the real world adversaries. 
+	$ \simulator $ behaves as $ \fcrs $ against the real world adversary.
 	\begin{itemize}
-		\item \textbf{[Simulation of $ \fcrs $:] }When simulating $ \fcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rel_2) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $. Whenever a party comes to learn the common reference string, $ \simulator $ gives $ crs $ as  $ \fcrs $.
+		\item \textbf{[Simulation of $ \fcrs $:] }When simulating $ \fcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rel_2) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $. Whenever a party comes to learn the $ crs $, $ \simulator $ gives $ crs $ as  $ \fcrs $.
 		
 		\item \textbf{[Simulation of $ \msg{keygen} $:]} Upon receiving $(\msg{keygen}, \sid, \user_i)$ from the functionality $\fgvrf$, $ \simulator $ samples $x \sample \FF_p$ and defines the key $X \defeq xG$. It adds $ xG $ to $ \hkeys $ and $ \vklist $ as a key of $ \user_i $. 
 		In the end, $ \simulator $ returns $(\msg{verificationkey}, \sid, X)$ to $\fgvrf$. %Whenever the honest party $ \user $ is corrupted by $ \env, $ $ \simulator $ moves the key of $ \user $ to $ \malkeys $ from $ \hkeys $.
 		
 		\item\textbf{[Simulation of the random oracles:]} We  describe how $ \simulator $ simulates the random oracles $ \hashG, \hash $ and $ \hash' $ against the real world adversaries. 	$ \simulator $ simulates  $ \hash' $  as a usual random oracle.
 		
-		$ \simulator $ simulates the random oracle $ \hashG $ as described in Figure \ref{oracle:Hg}. In short, it selects a random element  $ h $ from $ \FF_p $ for each new input and outputs $ hG_1 $ as an output. Thus, $ \simulator $ knows the discrete logarithm of each random oracle output of $\hashG  $.
+		$ \simulator $ simulates the random oracle $ \hashG $ as described in Figure \ref{oracle:Hg}. In short, it selects a random element  $ h $ from $ \FF_p $ for each new input and outputs $ hG_1 $ as an output of the random oracle $ \hashG $. Thus, $ \simulator $ knows the discrete logarithm of each random oracle output of $\hashG  $.
 		\begin{figure}
 			\centering
 			
@@ -99,8 +100,8 @@ We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $
 			\caption{The random oracle $ \hashG $}
 			\label{oracle:Hg}
 		\end{figure}
-	
-		The simulation of the random oracle $ \hash $ is less straightforward (See Figure \ref{oracle:H}). Whenever an input $ m, \pkring, W $ is given to $ \hash $, it first obtains the discrete logarithm $ h $ of $ \hashG(m, \pkring) $ from the $ \hashG $'s database. It needs this information to detect whether $ W $ could be the value which is generated for the evaluation (See $ \rvrf.\eval $ in $ \pvrf $). Remark that if it is $ W $-value (pre-output) of the evaluation, it should be equal to $ x^*\hashG(m, \pkring)= x^*hG_1 $  where $ x^* \in \FF_p$ is a some ring VRF secret key. For this, it obtains $ X^* = h^{-1}W $. If $ X^* \in \pkring $, $ \simulator $ consider this oracle call as  a computation of evaluation of the  message $ m $ with the public key $ X^* $ and the ring $ \pkring $.
+		
+		The simulation of the random oracle $ \hash $ is less straightforward (See Figure \ref{oracle:H}). Whenever an input $ m, \pkring, W $ is given to $ \hash $, it first obtains the discrete logarithm $ h $ of $ \hashG(m, \pkring) $ from the $ \hashG $'s database. It needs this information to detect whether $ W $ could be the value which is generated for the evaluation (See $ \rvrf.\eval $ in $ \pvrf $). Remark that if it is $ W $-value (pre-output) of the evaluation, it should be equal to $ x^*\hashG(m, \pkring)= x^*hG_1 $  where $ x^* \in \FF_p$ is a some ring VRF secret key. Therefore, it obtains  $ X^* = h^{-1}W $. If $ X^* \in \pkring $, $ \simulator $ considers this oracle call as  an evaluation of the  message $ m $ with the public key $ X^* $ and the ring $ \pkring $.
 		If $ X^* $ has not been registered as a malicious key, it registers it to $ \fgvrf $. Thus, $ \simulator $ has a right to ask to evaluation of the message $ m $ to $ \fgvrf $. It asks the evaluation of the message $ m $ with the key $ X^* $ and the ring $ \pkring $ and learns $ y $ from $ \fgvrf $ which is the evaluation of $ m $. Then, it sets $ y $ as the answer of the random oracle $ \hash $  for the input $ m, \pkring, W $. If $ X^* $ is registered as an honest party's key and $ \hash(m,\pkring,W) $ is not defined before, $ \simulator $ aborts and the simulation ends.
 		
 		\begin{figure}
@@ -113,7 +114,7 @@ We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $
 					$ P \leftarrow \hashG(m,\pkring) $\\			
 					$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $\\
 					$ X^* := h^{-1}W $ // candidate key \\
-					\textbf{if $ X^* \notin \pkring $} // it is not a evaluation query
+					\textbf{if $ X^* \notin \pkring $} // it is not an evaluation query
 					
 					\tab{$ y \sample \FF_p $}
 					
@@ -145,26 +146,28 @@ We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $
 			\caption{The random oracle $ \hash $}
 			\label{oracle:H}
 		\end{figure}
-	
-	\item \textbf{[Simulation of $ \msg{evalprove} $]} 
-	%The simulator has table  $\preoutputlist $ to keep the pre-outputs that it selects for each input and the ring of public keys. 
-	Upon receiving $(\msg{evalprove}, \sid, \pkring, m)$  from the functionality $\fgvrf$, $ \simulator $ generates the proof $ \pi $ as follows:
-	
-	For the first proof, it samples $ c, s, \delta \in \FF_p $ and $ C, W \in \GG$. Then, it lets the first proof be $\pi_1 =  (c, s, \delta) $. 
-	In addition, it sets $ R = sG_1+ \delta G_2- cC $ and $ R_m = s \hashG(m, \pkring)+ cW $ and lets $ \pkring,m, W,C, R, R_m$ be $ c $ in the table of the random oracle $ \hash' $ so that $ \pi_1 $ verifies in the real-world execution.  
-	%It adds $ W $ to the list $ \preoutputlist[m, \pkring] $.
-	
-	 $ \simulator $ gets the trapdoor $ \tau $ that it generated during the simulation of $ \fcrs $ to simulate the second proof. Then, it runs $ \mathsf{SNARK}.\mathsf{Simulate}(\rel_2,\tau, crs) $ and obtains $ \pi_2 $.
-	 
-	 In the end, $ \simulator $  responds by sending the message $(\msg{evalprove}, \sid, \pkring, m, \pi = (\pi_1, \pi_2, C, W))$ to the $ \fgvrf $. 
-	\item \textbf{[Simulation of $ \msg{verifiy} $]} Upon receiving  $(\msg{verify}, \sid, \pkring, m, y, \pi)$ from the functionality $\fgvrf$,  it runs $ \rvrf.\verify(\pkring, m, y, \pi) \rightarrow b $. If there exists no $ m, \pkring, W $ such that $ \mathtt{oracle\_queries\_h}[m, \pkring, W] = y $ and  $ b = 1  $, $ \simulator $ aborts. Otherwise, it returns $ (\msg{verified}, \sid, \pkring, m, y, \pi, b) $ to  $\fgvrf  $.
-%	\par\hrulefill
-	\item \textbf{[Simulation of $ \msg{link} $:]} Upon receiving $(\msg{link}, \sid, \pkring, X_i, m, y, \pi)$ from $\fgvrf$, $ \simulator $ obtains $ W $ from $ \pi $. Remark that $ \simulator $ gave $ \pi $ to $ \fgvrf $, so $ W $ must be the part of $ \pi $. Then, it picks random $ s, c $ and lets $ (X_i, m, sG_1-cX_i, s\hashG(m, \pkring)- cW) $ be $ c $ in the table of the random oracle $ \hash' $. It sends $ (\msg{link}, \sid, X_i,(s,c)) $ to $ \fgvrf $. Also, if $ \hash(m,\pkring, W) $ is not defined, it sets $ \mathtt{oracle\_queries\_h}[m, \pkring, W] = y$. If it is defined but not equal to $ y $, it aborts.
-	
-	%TODO \item receiving $(\msg{verifylink}, \sid, \vk_i, R, m, y, \hat\pi)$, send $(\msg{verify}, \sid, (X, H, Y), m, \hat\pi)$ to $\fnizk$.
-	\item \textbf{[Simulation of outputs of ideal honest parties:]} Whatever an honest party outputs in the ideal-world, $ \simulator $ outputs the same in the real-world simulation as an output of the same honest party. If the honest party's output is an evaluation value $ y $ and a proof $ \pi $ of an input $ m, \pkring $, $ \simulator $ checks whether the proof $ \pi $ of the evaluation $ y $ with the input $ m, \pkring $ is valid. For this,
-	% it checks whether $ \prooflist[\pi] $ is assigned to an input $ m $ and a ring key set $ \pkring $. If it is the case, 
-	it sends $ (\msg{verify}, \sid, \pkring, m, y, \pi) $ to $ \fgvrf $. If $ \fgvrf $ verifies it, $ \simulator $ retrieves $ W $ from $ \pi $ and sets $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ as $ y $ if $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ is not defined. $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ was already defined with another value, $ \simulator $ aborts. 
+		
+		\item \textbf{[Simulation of $ \msg{prove} $]} 
+		%The simulator has table  $\preoutputlist $ to keep the pre-outputs that it selects for each input and the ring of public keys. 
+		Upon receiving $(\msg{prove}, \sid, \pkring, m)$  from the functionality $\fgvrf$, $ \simulator $ generates the proof $ \pi $ as follows:
+		
+		For the first proof, it samples $ c, s, \delta \in \FF_p $ and $ C, W \in \GG$. Then, it lets the first proof be $\pi_1 =  (c, s, \delta) $. 
+		In addition, it sets $ R = sG_1+ \delta G_2+ cC $ and $ R_m = s \hashG(m, \pkring)+ cW $ and maps the input $ \pkring,m, W,C, R, R_m$ to $ c $ in the table of the random oracle $ \hash' $ so that $ \pi_1 $ verifies in the real-world execution.  
+		%It adds $ W $ to the list $ \preoutputlist[m, \pkring] $.
+		
+		$ \simulator $ gets the trapdoor $ \tau $ that it generated during the simulation of $ \fcrs $ to simulate the second proof. Then, it runs $ \mathsf{SNARK}.\mathsf{Simulate}(\rel_2,\tau, crs) $ and obtains $ \pi_2 $.
+		
+		In the end, $ \simulator $  responds by sending the message $(\msg{evalprove}, \sid, \pkring, m, \pi = (\pi_1, \pi_2, C, W))$ to the $ \fgvrf $. 
+		\item \textbf{[Simulation of $ \msg{verifiy} $]} Upon receiving  $(\msg{verify}, \sid, \pkring, m, y, \pi)$ from the functionality $\fgvrf$,  it runs $ \rvrf.\verify(\pkring, m, y, \pi) \rightarrow b $. 
+		%If there exists no $ m, \pkring, W $ such that $ \mathtt{oracle\_queries\_h}[m, \pkring, W] = y $ and  $ b = 1  $, $ \simulator $ aborts. Otherwise, 
+		It returns $ (\msg{verified}, \sid, \pkring, m, y, \pi, b) $ to  $\fgvrf  $.
+		%	\par\hrulefill
+		\item \textbf{[Simulation of $ \msg{link} $:]} Upon receiving $(\msg{link}, \sid, \pkring, X_i, m, y, \pi)$ from $\fgvrf$, $ \simulator $ obtains $ W $ from $ \pi $. Remark that $ \simulator $ gave $ \pi $ to $ \fgvrf $, so $ W $ must be the part of $ \pi $. Then, it picks random $ s, c $ and lets $ (X_i, m, sG_1-cX_i, s\hashG(m, \pkring)- cW) $ be $ c $ in the table of the random oracle $ \hash' $. It sends $ (\msg{link}, \sid, X_i,(s,c)) $ to $ \fgvrf $. Also, if $ \hash(m,\pkring, W) $ is not defined, it sets $ \mathtt{oracle\_queries\_h}[m, \pkring, W] = y$. If it is defined but not equal to $ y $, it aborts.
+		
+		%TODO \item receiving $(\msg{verifylink}, \sid, \vk_i, R, m, y, \hat\pi)$, send $(\msg{verify}, \sid, (X, H, Y), m, \hat\pi)$ to $\fnizk$.
+		\item \textbf{[Simulation of outputs of ideal honest parties:]} Whatever an honest party outputs in the ideal-world, $ \simulator $ outputs the same in the real-world simulation as an output of the same honest party. If the honest party's output is an evaluation value $ y $ and a proof $ \pi $ of an input $ m, \pkring $, $ \simulator $ checks whether the proof $ \pi $ of the evaluation $ y $ with the input $ m, \pkring $ is valid. For this,
+		% it checks whether $ \prooflist[\pi] $ is assigned to an input $ m $ and a ring key set $ \pkring $. If it is the case, 
+		it sends $ (\msg{verify}, \sid, \pkring, m, y, \pi) $ to $ \fgvrf $. If $ \fgvrf $ verifies it, $ \simulator $ retrieves $ W $ from $ \pi $ and sets $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ as $ y $ if $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ is not defined. $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ was already defined with another value, $ \simulator $ aborts. 
 	\end{itemize}
 	
 	
@@ -175,7 +178,7 @@ We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $
 	\begin{proof}
 		We prove this claim via a sequence of games. The initial game corresponds to the real protocol, whereas the final game corresponds to the simulator $\simulator$ described above. In each game, we change one (or more) step of in the ring VRF construction with the steps which are different in the simulation above.
 		\begin{enumerate}[label={{Game} }{{\arabic*}}, start = 0]
-		%\setlength\itemsep{0.1em}
+			%\setlength\itemsep{0.1em}
 			\item The simulator $ \simulator $ simulates the honest parties as in the ring VRF protocol that we describe in Section \ref{sec:ringvrfconstr}. 
 			
 			\item This game is the same as the previous game except that $ \simulator $ simulates the $ \fcrs $ functionality.  When simulating $ \fcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rel_2) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $ differently than the described $ \fcrs $ in Figure \ref{f:crs}. This game is indistinguishable from the previous game because 
@@ -190,7 +193,7 @@ We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $
 			In addition, it sets $ R = sG_1+ \delta G_2- cC $ and $ R_m = s \hashG(m, \pkring)+ cW $ and lets $ \pkring,m, W,C, R, R_m$ be $ c $ in the table of the random oracle $ \hash' $. Since the discrete logarithm of $ W $'s generated for the first proofs are unknown to $ \simulator $ in this game, it simulates the link proof $ \pi_\link $ of an input $ \pkring, X_i, m, y, \pi $ as follows: it obtains $ W $ from $ \pi $ and picks random $ s_\link,c_\link \in \FF_p$ and sets $ X_i, m, s_\link G_1 - c_\link X_i, s\hashG(m,\pkring) - c_\link W$ to be $ c_\link $ in the table of the oracle $ \hash' $. Remark that $ s,\delta,C $ in $ \pi_1 $ and $ s_\link $ in $ \pi_\link $ are from the uniformly random distribution as in the previous game. Therefore, they are indistinguishable. However, $ W $ is not computed as $x \hashG(m, \pkring) $ as in the previous game. Therefore, we should show that selecting $ W $ randomly from $ \GG $ and computing $ W $ as $x \hashG(m, \pkring) $ are indistinguishable.
 			We  show this under assumption that the decisional Diffie-Hellman (DDH) problem  is hard. We use the hybrid argument to show this.
 			
-			We define hybrid games $ H_{i} $ where $ \rvrf.\eval $ and $ \rvrf.\evalprove $ of the first $ i $ honest parties are computed as in the previous game and the rest are computed as in this game. Without loss of generality, $ \user_1, \user_2, \ldots, \user_{n_h} $ are the honest parties. Thus, $ H_0 $ is equivalent to \ref{game:DDH} and $ H_{n_h}  $ is equivalent to \ref{game:roracles}.  We construct an adversary $ \mathcal{B} $ that breaks the DDH problem given that there exists an adversary that distinguishes hybrid games $ H_i $ and $ H_{i + 1} $ for $ 0 \leq i < n_h $. $ \mathcal{B} $ receives the DDH challenges $ X,Y, Z \in \GG $ from the DDH game and simulates the game against $ \adv $ as follows: $ \mathcal{B} $ generates the public key of all  honest parties' key as usual by running $ \rvrf.\keygen$ except party $ \user_{i+1} $. It lets $ \user_{i+1} $'s public key be $ X $. Differently, it simulates the random oracle $ \hashG $ against $ \adv $ as described in Figure \ref{oracle:HgbyB}. Remark that this simulation is indistinguishable.
+			We define hybrid games $ H_{i} $ where $ \rvrf.\eval $ and $ \rvrf.\evalprove $ of the first $ i $ honest parties are computed as in the previous game and the rest are computed as in this game. Without loss of generality, $ \user_1, \user_2, \ldots, \user_{n_h} $ are the honest parties. Thus, $ H_0 $ is equivalent to \ref{game:DDH} and $ H_{n_h}  $ is equivalent to \ref{game:roracles}.  We construct an adversary $ \mathcal{B} $ that breaks the DDH problem given that there exists an adversary that distinguishes hybrid games $ H_i $ and $ H_{i + 1} $ for $ 0 \leq i < n_h $. $ \mathcal{B} $ receives the DDH challenges $ X,Y, Z \in \GG $ from the DDH game and simulates the game against $ \adv $ as follows: $ \mathcal{B} $ generates the public key of all  honest parties' key as usual by running $ \rvrf.\keygen$ except party $ \user_{i+1} $. It lets $ \user_{i+1} $'s public key be $ X $. Differently, it simulates the random oracle $ \hashG $ against $ \adv $ as described in Figure \ref{oracle:HgbyB}. Remark that this simulation of $ \hashG $ by $ \mathcal{B} $ is indistinguishable.
 			
 			\begin{figure}
 				\centering
@@ -218,13 +221,13 @@ We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $
 				\label{oracle:HgbyB}
 			\end{figure}
 			
-			$ \mathcal{B} $ simulates the first $ i $ parties as in \ref{game:roracles} and the parties $ \user_{i+2}, \ldots, \user_q $ as in \ref{game:roracles}. The simulation of $ \user_{i + 1} $ is different. Whenever, $ \user_{i+1} $ needs to output evaluation of an input $ m, \pkring $, it obtains $ P = \hashG(m, \pkring) = hY $ from $ \mathtt{oracle\_queries\_gg} $, lets $ W = hZ $ and outputs $ \hash(m, \pkring, W) $. Remark that if $ (X,Y,Z)$ is a DH triple (i.e., $  \mathsf{DH}(X,Y,Z) \rightarrow 1 $), $ \user_{i+1} $ is simulated as in \ref{game:roracles} because $ W = xP $ in this case. Otherwise, $ \user_{i+1} $ is simulated as in \ref{game:DDH} because $ W $ is random. So, if $  \mathsf{DH}(X,Y,Z)  \rightarrow 1$, $ \mathcal{B} $ simulates $ H_{i+1} $. Otherwise, it simulates $ H_{i} $. In the end of the simulation, if $ \adv $ outputs $ i $, $ \mathcal{B} $ outputs $ 0 $ meaning $  \mathsf{DH}(X,Y,Z) \rightarrow 0$. Otherwise, it outputs $ i + 1 $. The success probability of $ \mathcal{B} $'s is equal to the success probability of $ \adv $ who distinguishes $ H_i $ and $ H_{i +1} $. Since DDH problem is hard, $ \mathcal{B} $ has negligible advantage in the DDH game. So, $ \adv $ has a negligible advantage too. Hence, from the hybrid argument, we can conclude that $ H_0  = $\ref{game:DDH} and $ H_q = $ \ref{game:roracles} are indistinguishable.
+			$ \mathcal{B} $ simulates the first $ i $ parties as in \ref{game:roracles} and the parties $ \user_{i+2}, \ldots, \user_q $ as in \ref{game:roracles}. The simulation of $ \user_{i + 1} $ is different. Whenever, $ \user_{i+1} $ needs to output evaluation of an input $ m, \pkring $, it obtains $ P = \hashG(m, \pkring) = hY $ from $ \mathtt{oracle\_queries\_gg} $, lets $ W = hZ $ and outputs $ \hash(m, \pkring, W) $. Remark that if $ (X,Y,Z)$ is a DH triple (i.e., $  \mathsf{DH}(X,Y,Z) \rightarrow 1 $), $ \user_{i+1} $ is simulated as in \ref{game:roracles} because $ W = xP $ in this case. Otherwise, $ \user_{i+1} $ is simulated as in \ref{game:DDH} because $ W $ is random. So, if $  \mathsf{DH}(X,Y,Z)  \rightarrow 1$, $ \mathcal{B} $ simulates $ H_{i+1} $. Otherwise, it simulates $ H_{i} $. In the end of the simulation, if $ \adv $ outputs $ i $, $ \mathcal{B} $ outputs $ 0 $ meaning $  \mathsf{DH}(X,Y,Z) \rightarrow 0$. Otherwise, it outputs $ i + 1 $. The success probability of $ \mathcal{B} $ is equal to the success probability of $ \adv $ who distinguishes $ H_i $ and $ H_{i +1} $. Since DDH problem is hard, $ \mathcal{B} $ has negligible advantage in the DDH game. So, $ \adv $ has a negligible advantage too. Hence, from the hybrid argument, we can conclude that $ H_0  = $\ref{game:DDH} and $ H_q = $ \ref{game:roracles} are indistinguishable.
 			
 			
 			
 			\item \label{game:gdh}This game is the same as in the previous game except that $ \simulator $ starts to simulate the random oracle $ \hash $ as described in Figure \ref{oracle:Hgame}. We remark that the output of the simulation of $ \hash $ in this game and the output of the simulation of $ \hash $ in Figure \ref{oracle:H} are the same. The simulation of $ \hash $ in this game does not ask for the evaluation $ m, \pkring, W $ to $ \fgvrf $ for a malicious key $ X^* $ instead it picks the evaluation output randomly from $ \FF_p $. Since  $ \fgvrf $ also picks the evaluation output of $ m, \pkring, W $ from $ \FF_p $ randomly, this difference does not change the output distribution of the simulation of the random oracle $ \hash $ in Figure \ref{oracle:H} and $ \hash $ in Figure \ref{oracle:Hgame}.
 			
-				\begin{figure}
+			\begin{figure}
 				\centering
 				
 				\noindent\fbox{%
@@ -309,139 +312,139 @@ We next show that our ring VRF construction realizes $ \fgvrf $ in the $ \fcrs $
 				\label{oracle:HbyB}
 			\end{figure}
 			
-			If $ \mathcal{B} $ aborts during the simulation of $ \hash $, it means that $ X^* $ belongs to an honest party and $ DH(X^*,Y,Z) \leftarrow 1 $. We know the honest public key $ X^* $ is generated as $ r^*X $ for $ r^* \in \FF_p $. Therefore, $ (r^*)^{-1}Z $ is the CDH solution of $ X,Y $. This shows that if the probability of abort in the random oracle $ \hash $ is equal to the probability of solving the GDH problem. Therefore, \ref{game:gdh} and \ref{game:DDH} are indistinguishable.
+			If $ \mathcal{B} $ aborts during the simulation of $ \hash $, it means that $ X^* $ belongs to an honest party and $ DH(X^*,Y,Z) \rightarrow 1 $. We know the honest public key $ X^* $ is generated as $ r^*X $ for $ r^* \in \FF_p $. Therefore, $ (r^*)^{-1}Z $ is the CDH solution of $ X,Y $. This shows that if the probability of abort in the random oracle $ \hash $ is equal to the probability of solving the GDH problem. Therefore, \ref{game:gdh} and \ref{game:DDH} are indistinguishable.
 			
-%			Consider the one-more GDH game in the group $ \GG $ with the generator $ G_1 $, challenges $ X = xG_1, P_1, P_2, \ldots, P_{q_{h_g}} \in \GG$ and access to the Diffie-Hellman oracle $ \mathsf{DH}(.,.,.) $ and the oracle  $\mathcal{O}_x(.) $ which returns $ xP $ given $ P $. The OM-GDH challenges are given to the adversary $ \mathcal{B} $ and $ \mathcal{B} $ starts to simulate the Game 3 to the adversary $ \adv $. The simulation is exactly the same except that $ \mathcal{B} $ picks a random $ r_i \in \ZZ_p $ and generates the public key of each party as $ X_i = r_iX $. In this case, $ \mathcal{B} $ does not know the corresponding secret keys. Therefore, when it needs to run the evaluation, it obtains the pre-output value of the given input $ \pkring,m $ and public key $ X_i $ by asking $ \mathcal{O}_x(.) $ with the input $ P $ where $ P = \hashG(m, \pkring) $ and lets the pre-output be $ W = r_i\mathcal{O}_x(P) $ (See Figure \ref{sim:preoutputs}).  Since $ n_e \leq q_h $, $ \mathcal{B} $ has enough source to compute the pre-outputs. 
-%			
-%			
-%			\begin{figure}
-%				\centering
-%				
-%				\noindent\fbox{%
-%					\parbox{5cm}{%
-%						\underline{\textbf{Computation of  pre-outputs}} \\
-%							\textbf{Input:} $ X_i, m, \pkring $ 
-%							
-%							$ P := \hashG(m, \pkring) $
-%							
-%							\textbf{if}   $ \lst[P] = \perp $
-%							
-%							\tab{$ Q \leftarrow \mathcal{O}_x(P) $}
-%							
-%							\tab{$ \lst[P] := Q $}
-%							
-%							\textbf{else}:
-%							
-%							\tab{$ Q := \lst[P] $}
-%							
-%							\textbf{return $ r_iQ $}
-%							
-%					}}	
-%					\caption{The simulation of pre-outputs by $ \mathcal{B} $. }
-%					\label{sim:preoutputs}
-%				\end{figure}
-%			
-%			
-%			
-%			Besides, $ \mathcal{B} $ simulates the random oracles $ \hash $ and $ \hashG $ differently as described in Figure \ref{oracle:HbyB} and Figure \ref{oracle:HgbyB}.  
-%			
-%			The simulation of the random oracle $ \hashG $, $ \bdv $ returns $ P_i $ (one of the OM-GDH challenge). Since $ P_1, P_2, \ldots, P_{q_{h_g}} $ are generated randomly. the new simulation of $ \hashG $ is indistinguishable from the simulation in Game 3 (Figure \ref{oracle:Hg}).
-%			
-%			\begin{figure}
-%				\centering
-%				
-%				\noindent\fbox{%
-%					\parbox{8cm}{%
-%						\underline{\textbf{Oracle $ \hashG $ in Game 2 by the CDH adversary $ \mathcal{B} $}} \\
-%						\textbf{Input:} $ m, \pkring $ 
-%						
-%						$ \ell := \ell + 1 $
-%						
-%						\textbf{if} $\mathtt{oracle\_queries\_gg}[m, \pkring] = \perp  $
-%						  
-%						\tab{\fbox{$ P \leftarrow P_\ell $}}
-%						
-%						\tab{$\mathtt{oracle\_queries\_gg}[m, \pkring] := P$}
-%						
-%						\textbf{else}:
-%						
-%						\tab{\fbox{$ P \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $}}
-%						
-%						\textbf{return $ P $}
-%						
-%				}}	
-%				\caption{The simulation of the random oracle $ \hashG $ by $ \mathcal{B} $. The different steps than Figure \ref{oracle:Hg} are in the box.}
-%				\label{oracle:HgbyB}
-%			\end{figure}
-%			
-%			$ \mathcal{B} $ simulates the random oracle $ \hash $ as described in Figure \ref{oracle:HbyB}. The only difference is the way of finding out whether the query is possibly done for the evaluation. Remember that $ \hashG $ is simulated differently by $ \mathcal{B} $. 
-%			Therefore, computing $ h^{-1}W $ does not work in this simulation to deduce the candidate key because $ h $ which is the discrete logarithm of $ \hashG(m, \pkring) $ is not known. Instead, $ \bdv $ gets advantage of having the access to $ \mathsf{DH} $ oracle to learn whether $ W $ is generated from one of the public keys in $ \pkring $ i.e., check whether $ \mathsf{DH}(X^*, P, W) \rightarrow 1$ for each $ X^* \in \pkring $ where $ P = \hashG(m, \pkring) $. This step is indistinguishable from checking whether $ X^* = h^{-1}W $ in the simulation in Figure \ref{oracle:Hgame} because it does the same computation.
-%			
-%			
-%			%, it does not find a candidate key $ X^* $ if $ W $ is generated from one of the public keys in $ \pkring $ i.e., $ W = x^*\hashG(m, \pkring) $. The reason of this, if $ W $ is generated from one of the public keys in $ \pkring $, $X =  h^{-1}W = h^{-1} x^*\hashG(m, \pkring)  = x^*Y \neq X^*$. Therefore, $ \bdv $ gets advantage of having the access to $ \mathsf{DH} $ oracle to learn whether $ W $ is generated from one of the public keys in $ \pkring $ i.e., check whether $ \mathsf{DH}(X^*, Y, Z) \rightarrow 1$ for each $ X^* \in \pkring $. This step is indistinguishable from checking whether $ X^* = h^{-1}W $ in the simulation in Figure \ref{oracle:Hgame}.
-%				
-%				\begin{figure}[h]
-%				\centering
-%				
-%				\noindent\fbox{%
-%					\parbox{8cm}{%
-%						\underline{\textbf{Oracle $ \hash$}} \\
-%						\textbf{Input:} $ m, \pkring,W $ \\			
-%						$ P \leftarrow \hashG(m,\pkring) $\\			
-%						\sout{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $}
-%						\begin{mdframed}
-%						
-%						$ X^* := \mathsf{null} $
-%						
-%						%$ Z := h^{-1}W $  
-%					
-%						\textbf{for $ X \in \pkring $}
-%						
-%						\tab{\textbf{if} $ \mathsf{DH}(X^*,P,W) \rightarrow 1 $}
-%						
-%						\tab{$ X^* := X $}
-%						
-%					   \end{mdframed}
-%						\textbf{\textbf{if} $ X^* \notin \pkring $}
-%						
-%						\tab{$ y \sample \FF_p $}
-%						
-%						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
-%						
-%						{\textbf{else if} $ X^* \in \malkeys$}
-%						
-%						\tab{$ y \sample \FF_p $}
-%						
-%						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
-%						
-%						{\textbf{else if} $ \mathtt{oracle\_queries\_h}[m, \pkring, W]  = \perp$}
-%						
-%						\tab{\textbf{return} \textsc{Abort}}
-%						
-%						\textbf{return $  \mathtt{oracle\_queries\_h}[m, \pkring, W] $}
-%						
-%				}}	
-%				\caption{The simulation of the random oracle $ \hash $ by $ \mathcal{B} $. The removed steps are crossed out. The different steps than Figure \ref{oracle:Hgame} are in the box.}
-%				\label{oracle:HbyB}
-%			\end{figure}
-%		
-%			If $ \mathcal{B} $ aborts during the simulation of $ \hash $, it means that $ \mathcal{A} $ obtained $ W $ before the honest party with the public key $ X^* $ runs the evaluation algorithm. Given that $ \mathcal{B} $ runs the evaluation at most $ n_e \leq  q_{h_g} $ times, if abort occurs during the simulation of $ \hash $, the number of evaluations is when the abort occurs at most $ q_{h_g} - 1$. The reason of this, if $ n_e = q_{h_g} $, it means that all  $ \hashG $ queries are used up by $ \mathcal{B} $ for number of  $ n_e = q_{h_g} $ evaluations and so the abort case in the simulation of $ \hash $ cannot occur. Therefore, when  abort occurs in $ \hash $, it means that $ n_e \leq q_{h_g} - 1 $.  In the end, $ \mathcal{B} $ outputs $ \{\lst{P}\}_{P \in \setsym{C}} $ to the OM-GDH game. The success probability of $ \mathcal{B} $ solving the OM-GDH problem is equal to the probability that abort occurs in $ \hash $. So, the probability of abortion during the simulation of $ \hash $ in this game is negligible.
+			%			Consider the one-more GDH game in the group $ \GG $ with the generator $ G_1 $, challenges $ X = xG_1, P_1, P_2, \ldots, P_{q_{h_g}} \in \GG$ and access to the Diffie-Hellman oracle $ \mathsf{DH}(.,.,.) $ and the oracle  $\mathcal{O}_x(.) $ which returns $ xP $ given $ P $. The OM-GDH challenges are given to the adversary $ \mathcal{B} $ and $ \mathcal{B} $ starts to simulate the Game 3 to the adversary $ \adv $. The simulation is exactly the same except that $ \mathcal{B} $ picks a random $ r_i \in \ZZ_p $ and generates the public key of each party as $ X_i = r_iX $. In this case, $ \mathcal{B} $ does not know the corresponding secret keys. Therefore, when it needs to run the evaluation, it obtains the pre-output value of the given input $ \pkring,m $ and public key $ X_i $ by asking $ \mathcal{O}_x(.) $ with the input $ P $ where $ P = \hashG(m, \pkring) $ and lets the pre-output be $ W = r_i\mathcal{O}_x(P) $ (See Figure \ref{sim:preoutputs}).  Since $ n_e \leq q_h $, $ \mathcal{B} $ has enough source to compute the pre-outputs. 
+			%			
+			%			
+			%			\begin{figure}
+			%				\centering
+			%				
+			%				\noindent\fbox{%
+			%					\parbox{5cm}{%
+			%						\underline{\textbf{Computation of  pre-outputs}} \\
+			%							\textbf{Input:} $ X_i, m, \pkring $ 
+			%							
+			%							$ P := \hashG(m, \pkring) $
+			%							
+			%							\textbf{if}   $ \lst[P] = \perp $
+			%							
+			%							\tab{$ Q \leftarrow \mathcal{O}_x(P) $}
+			%							
+			%							\tab{$ \lst[P] := Q $}
+			%							
+			%							\textbf{else}:
+			%							
+			%							\tab{$ Q := \lst[P] $}
+			%							
+			%							\textbf{return $ r_iQ $}
+			%							
+			%					}}	
+			%					\caption{The simulation of pre-outputs by $ \mathcal{B} $. }
+			%					\label{sim:preoutputs}
+			%				\end{figure}
+			%			
+			%			
+			%			
+			%			Besides, $ \mathcal{B} $ simulates the random oracles $ \hash $ and $ \hashG $ differently as described in Figure \ref{oracle:HbyB} and Figure \ref{oracle:HgbyB}.  
+			%			
+			%			The simulation of the random oracle $ \hashG $, $ \bdv $ returns $ P_i $ (one of the OM-GDH challenge). Since $ P_1, P_2, \ldots, P_{q_{h_g}} $ are generated randomly. the new simulation of $ \hashG $ is indistinguishable from the simulation in Game 3 (Figure \ref{oracle:Hg}).
+			%			
+			%			\begin{figure}
+			%				\centering
+			%				
+			%				\noindent\fbox{%
+			%					\parbox{8cm}{%
+			%						\underline{\textbf{Oracle $ \hashG $ in Game 2 by the CDH adversary $ \mathcal{B} $}} \\
+			%						\textbf{Input:} $ m, \pkring $ 
+			%						
+			%						$ \ell := \ell + 1 $
+			%						
+			%						\textbf{if} $\mathtt{oracle\_queries\_gg}[m, \pkring] = \perp  $
+			%						  
+			%						\tab{\fbox{$ P \leftarrow P_\ell $}}
+			%						
+			%						\tab{$\mathtt{oracle\_queries\_gg}[m, \pkring] := P$}
+			%						
+			%						\textbf{else}:
+			%						
+			%						\tab{\fbox{$ P \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $}}
+			%						
+			%						\textbf{return $ P $}
+			%						
+			%				}}	
+			%				\caption{The simulation of the random oracle $ \hashG $ by $ \mathcal{B} $. The different steps than Figure \ref{oracle:Hg} are in the box.}
+			%				\label{oracle:HgbyB}
+			%			\end{figure}
+			%			
+			%			$ \mathcal{B} $ simulates the random oracle $ \hash $ as described in Figure \ref{oracle:HbyB}. The only difference is the way of finding out whether the query is possibly done for the evaluation. Remember that $ \hashG $ is simulated differently by $ \mathcal{B} $. 
+			%			Therefore, computing $ h^{-1}W $ does not work in this simulation to deduce the candidate key because $ h $ which is the discrete logarithm of $ \hashG(m, \pkring) $ is not known. Instead, $ \bdv $ gets advantage of having the access to $ \mathsf{DH} $ oracle to learn whether $ W $ is generated from one of the public keys in $ \pkring $ i.e., check whether $ \mathsf{DH}(X^*, P, W) \rightarrow 1$ for each $ X^* \in \pkring $ where $ P = \hashG(m, \pkring) $. This step is indistinguishable from checking whether $ X^* = h^{-1}W $ in the simulation in Figure \ref{oracle:Hgame} because it does the same computation.
+			%			
+			%			
+			%			%, it does not find a candidate key $ X^* $ if $ W $ is generated from one of the public keys in $ \pkring $ i.e., $ W = x^*\hashG(m, \pkring) $. The reason of this, if $ W $ is generated from one of the public keys in $ \pkring $, $X =  h^{-1}W = h^{-1} x^*\hashG(m, \pkring)  = x^*Y \neq X^*$. Therefore, $ \bdv $ gets advantage of having the access to $ \mathsf{DH} $ oracle to learn whether $ W $ is generated from one of the public keys in $ \pkring $ i.e., check whether $ \mathsf{DH}(X^*, Y, Z) \rightarrow 1$ for each $ X^* \in \pkring $. This step is indistinguishable from checking whether $ X^* = h^{-1}W $ in the simulation in Figure \ref{oracle:Hgame}.
+			%				
+			%				\begin{figure}[h]
+			%				\centering
+			%				
+			%				\noindent\fbox{%
+			%					\parbox{8cm}{%
+			%						\underline{\textbf{Oracle $ \hash$}} \\
+			%						\textbf{Input:} $ m, \pkring,W $ \\			
+			%						$ P \leftarrow \hashG(m,\pkring) $\\			
+			%						\sout{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \pkring] $}
+			%						\begin{mdframed}
+			%						
+			%						$ X^* := \mathsf{null} $
+			%						
+			%						%$ Z := h^{-1}W $  
+			%					
+			%						\textbf{for $ X \in \pkring $}
+			%						
+			%						\tab{\textbf{if} $ \mathsf{DH}(X^*,P,W) \rightarrow 1 $}
+			%						
+			%						\tab{$ X^* := X $}
+			%						
+			%					   \end{mdframed}
+			%						\textbf{\textbf{if} $ X^* \notin \pkring $}
+			%						
+			%						\tab{$ y \sample \FF_p $}
+			%						
+			%						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
+			%						
+			%						{\textbf{else if} $ X^* \in \malkeys$}
+			%						
+			%						\tab{$ y \sample \FF_p $}
+			%						
+			%						\tab{$  \mathtt{oracle\_queries\_h}[m, \pkring, W]:=y $}
+			%						
+			%						{\textbf{else if} $ \mathtt{oracle\_queries\_h}[m, \pkring, W]  = \perp$}
+			%						
+			%						\tab{\textbf{return} \textsc{Abort}}
+			%						
+			%						\textbf{return $  \mathtt{oracle\_queries\_h}[m, \pkring, W] $}
+			%						
+			%				}}	
+			%				\caption{The simulation of the random oracle $ \hash $ by $ \mathcal{B} $. The removed steps are crossed out. The different steps than Figure \ref{oracle:Hgame} are in the box.}
+			%				\label{oracle:HbyB}
+			%			\end{figure}
+			%		
+			%			If $ \mathcal{B} $ aborts during the simulation of $ \hash $, it means that $ \mathcal{A} $ obtained $ W $ before the honest party with the public key $ X^* $ runs the evaluation algorithm. Given that $ \mathcal{B} $ runs the evaluation at most $ n_e \leq  q_{h_g} $ times, if abort occurs during the simulation of $ \hash $, the number of evaluations is when the abort occurs at most $ q_{h_g} - 1$. The reason of this, if $ n_e = q_{h_g} $, it means that all  $ \hashG $ queries are used up by $ \mathcal{B} $ for number of  $ n_e = q_{h_g} $ evaluations and so the abort case in the simulation of $ \hash $ cannot occur. Therefore, when  abort occurs in $ \hash $, it means that $ n_e \leq q_{h_g} - 1 $.  In the end, $ \mathcal{B} $ outputs $ \{\lst{P}\}_{P \in \setsym{C}} $ to the OM-GDH game. The success probability of $ \mathcal{B} $ solving the OM-GDH problem is equal to the probability that abort occurs in $ \hash $. So, the probability of abortion during the simulation of $ \hash $ in this game is negligible.
 			
-			\item This game is the same as the previous game except that if $ \simulator $ receives evaluation and proof $ y, \pi $ for the input $ m, \pkring $, but $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ where $ W \in \pi $ is not defined and $ \rvrf.\verify(\pkring, m, y, \pi) \rightarrow 1$, $ \simulator $ aborts. If $ \rvrf.\verify(\pkring, m, y, \pi) \rightarrow 1$,  $ y = \hash(m, \pkring,W) $. So, it means that $ \adv $ guessed the output of $ \hash(m, \pkring,W) $ without asking the random oracle $ \hash $. Since the probability that it happens is negligible, this game is indistinguishable from the previous game.
+			%	\item This game is the same as the previous game except that if $ \simulator $ receives evaluation and proof $ y, \pi $ for the input $ m, \pkring $, but $ \mathtt{oracle\_queries\_h}[m, \pkring, W] $ where $ W \in \pi $ is not defined and $ \rvrf.\verify(\pkring, m, y, \pi) \rightarrow 1$, $ \simulator $ aborts. If $ \rvrf.\verify(\pkring, m, y, \pi) \rightarrow 1$,  $ y = \hash(m, \pkring,W) $. So, it means that $ \adv $ guessed the output of $ \hash(m, \pkring,W) $ without asking the random oracle $ \hash $. Since the probability that it happens is negligible, this game is indistinguishable from the previous game.
 			
-%			Simulation verify is indistinguishable because the only way for the environment to learn $ y $ is asking the evaluation of the $ m, \pkring $ from the adversary. The adversary can learn it from the random oracle. This game guarantees that the evaluation is stored in the random oracle $ \hash $'s database 
+			%			Simulation verify is indistinguishable because the only way for the environment to learn $ y $ is asking the evaluation of the $ m, \pkring $ from the adversary. The adversary can learn it from the random oracle. This game guarantees that the evaluation is stored in the random oracle $ \hash $'s database 
 			The last game is exactly the same as the simulator that we described for $ \fgvrf $. This shows that the simulator $ \simulator $ that we describe for $ \fgvrf $ is indistinguishable from the real protocol. So, the environment $ \env $ cannot distinguish the real-world simulation from the real protocol except with a negligible probability. 
-				
-		
+			
+			
 		\end{enumerate}
-	\qed
+		\qed
 	\end{proof}	
-
+	
 	\begin{claim}
 		The distributions of the outputs of honest and malicious parties in ideal and real worlds are indistinguishable.
 	\end{claim}
 	$ \simulator $ outputs whatever the honest parties output in the ideal-world. 
 	Therefore, the output of the honest parties are identical. While outputting them, it updates the random oracles respectively so that the verification process of these outputs (either $ \rvrf.\verify $ or $ \rvrf.\link\verify $) verifies in the real protocol. The cases where $ \simulator $ aborts happens if corresponding random oracle input is already assigned to another value which can happen with a negligible probability. Therefore, the outputs in the real and ideal world are indistinguishable.
 	
-\qed
+	\qed
 \end{proof}
diff --git a/papers/rvrf/rvrf_functionality.tex b/papers/rvrf/rvrf_functionality.tex
index 2bb54cb..0a1a883 100644
--- a/papers/rvrf/rvrf_functionality.tex
+++ b/papers/rvrf/rvrf_functionality.tex
@@ -1,38 +1,37 @@
 \begin{figure}
-	\scriptsize
 	\begin{tcolorbox}
 		{  \begin{description}
 				\item[Key Generation.] upon receiving a message $(\msg{keygen}, \sid)$ from a party $\user_i$, send $(\msg{keygen}, \sid, \user_i)$ to the simulator $\simulator$.
 				Upon receiving a message $(\msg{verificationkey}, \sid, \pkrvrf)$ from $\simulator$, verify that $\pkrvrf$ has not been recorded before; then, store in the table $\vklist$, under $\user_i$, the value $\pkrvrf$.
-				Return $(\msg{verificationkey}, \sid, \pkrvrf)$.
+				Return $(\msg{verificationkey}, \sid, \pkrvrf)$ to $ \user_i$.
 				
 				\item[Malicious Key Generation.] upon receiving a message $(\msg{keygen}, \sid, \pkrvrf)$ from $\simulator$, verify that $\pkrvrf$ was not yet recorded, and if so record in the table $\vklist$ the value $\pkrvrf$ under $\simulator$. Else, ignore the message.
 				
 				\item[VRF Evaluation.] upon receiving a message $(\msg{eval}, \sid, \pkring, \pkvrf_i, m)$ from $\user_i$, verify that $\pkrvrf_i \in \pkring$ and if there exists $ \pkvrf_i $ in $\vklist $ associated with $ \user_i $. If that was not the case, just ignore the request.
-				If $\evaluationslist[\pkring, m][\pkrvrf_i]$ is empty, then sample a new $y \sample \bin^{\ell(\secpar)}$ and store the pair $y$ in the array associated to the message $m$ and the ring $\pkring$. That is, store $\evaluationslist[\pkring, m][\pkrvrf_i] = y$.
-				Let sets $\prooflist[\pkring, m][\pkrvrf_i] = \emptylist$ and $\Linklist[\pkring, m][\pkrvrf_i] = \emptylist$ if $ \prooflist[\pkring, m][\pkrvrf_i] $ and $\Linklist[\pkring, m][\pkrvrf_i] = \emptylist$ do not exits. Return $(\msg{evaluated}, sid, \pkring, m, y)$ to $ \user_i $.
+				If $\evaluationslist[\pkring, m][\pkrvrf_i]$ is empty, then sample  $y \sample \bin^{\ell_\rvrf}$ and store $y$ in the array associated to the message $m$ and the ring $\pkring$. That is, store $\evaluationslist[\pkring, m][\pkrvrf_i] = y$.
+				Let sets $\prooflist[\pkring, m][\pkrvrf_i] = \emptylist$ and $\Linklist[\pkring, m][\pkrvrf_i] = \emptylist$ if $ \prooflist[\pkring, m][\pkrvrf_i] $ and $\Linklist[\pkring, m][\pkrvrf_i] = \emptylist$ do not exits. Return $(\msg{evaluated}, \sid, \pkring, m, y)$ to $ \user_i $.
 				
 				
-				\item[VRF evaluation and proof.] upon receiving a message $(\msg{evalprove}, \sid, \pkring, \pkrvrf_i, m)$ from $\user_i$, verify that $\pkrvrf_i \in \pkring$ and that there exists a public key $\pkrvrf_i$ associated to $\user_i$ in the table $ \vklist $. If that wasn't the case, just ignore the request.
-				Send $(\msg{evalprove}, \sid, \pkring, m)$ to $\simulator$. Upon receiving $(\msg{eval}, \sid, \pkring, m, \pi)$ as a response from $\simulator$, if $\evaluationslist[\pkring, m][\pkrvrf_i]$ is not set, select $y \sample \bin^{\ell(\secpar)}$ and set $\evaluationslist[\pkring, m][\pkrvrf_i]$ to be $y$; set $\prooflist[\pkring, m][\pkrvrf_i] = \set{\pi}$. Otherwise, let $y \defeq \evaluationslist[\pkring, m][\pkrvrf_i]$; update the list of proofs $\prooflist[\pkring, m][\pkrvrf_i]$ by adding $\pi$. Return $(\msg{evaluated\&proved}, \sid, \pkring,m, y, \pi)$ to $\user_i$.
+				\item[VRF evaluation and proof.] upon receiving a message $(\msg{prove}, \sid, \pkring, \pkrvrf_i, m)$ from $\user_i$, verify that $\pkrvrf_i \in \pkring$ and that there exists a public key $\pkrvrf_i$ associated to $\user_i$ in the table $ \vklist $. If that wasn't the case, just ignore the request.
+				Send $(\msg{prove}, \sid, \pkring, m)$ to $\simulator$. Upon receiving $(\msg{proof}, \sid, \pkring, m, \pi)$ as a response from $\simulator$, if $\evaluationslist[\pkring, m][\pkrvrf_i]$ is not set, select $y \sample \bin^{\ell_{\rvrf}}$ and set $\evaluationslist[\pkring, m][\pkrvrf_i]$ to be $y$; set $\prooflist[\pkring, m][\pkrvrf_i] = \set{\pi}$. Otherwise, let $y \defeq \evaluationslist[\pkring, m][\pkrvrf_i]$; update the list of proofs $\prooflist[\pkring, m][\pkrvrf_i]$ by adding $\pi$. Return $(\msg{proof}, \sid, \pkring,m, y, \pi)$ to $\user_i$.
 				
 				%\item[Malicious VRF evaluation.] upon receiving a message $(\msg{evalprove}, \sid, \pkring, m)$ from $\simulator$, check that $\vklist$ has a public key associated to $\simulator$. If not, ignore the request. If $\evaluationslist[\pkring, m][\simulator]$ is not set, sample $y \sample \bin^{\ell(\secpar)}$ and set $\evaluationslist[\pkring, m][\simulator] \defeq y$ (and $\prooflist[\pkring,m]$ to $\emptyset$). If $\prooflist[\pkring, m]$ contains a proof (i.e., if $\prooflist[\pkring, m]$ is not empty), return $(\msg{evaluated}, \sid, y)$ to $\simulator$. Else, ignore the request.
 				
 				%\item[Verification.] upon receiving a message $(\msg{verify}, \sid, \pkring, m, y, \pi)$, from any party forward the message to the simulator. If there exists a $\pkrvrf_i$ among the values of \texttt{verification\_keys}, and there exists $\pi \in \prooflist[\pkring, m]$, set $b = 1$. Else, set $b =0$. Finally, output $(\msg{verified}, \sid, \pkring, m, y, \pi, b)$.
-				\item[Verification.] upon receiving a message $(\msg{verify}, \sid, \pkring, m, y, \pi)$, set $ b = 0 $ and check if there exists a  $\pkrvrf_i \in \pkring$ and  in $ \vklist $ such that $ \evaluationslist[\pkring,m][\pkvrf_i] = y $. 
+				\item[Verification.] upon receiving a message $(\msg{verify}, \sid, \pkring, m, y, \pi)$ from a party, set $ b = 0 $ and check if there exists a  $\pkrvrf_i \in \pkring$ and  in $ \vklist $ such that $ \evaluationslist[\pkring,m][\pkvrf_i] = y $. 
 				\begin{itemize}
-					\item If not, set $ b = 0 $.
-					\item If there exists a $ \pkrvrf_i $ such that $ \evaluationslist[\pkring,m][\pkvrf_i] = y$, $ \pkrvrf_i $ is a malicious key and   $\pi \notin \prooflist[\pkring, m][\pkvrf_i]$, forward the message to $ \simulator $. Upon receiving $ (\msg{Verified}, \sid,\pkring, m, y, \pi, b') $ from $ \simulator $. Set $ b = b' $. If $ b' = 1 $, append $ \pi $ to $ \prooflist[\pkring, m][\pkvrf_i] $.
+					%\item If not, set $ b = 0 $.
+					\item If  $ \pkrvrf_i $ is a malicious key and   $\pi \notin \prooflist[\pkring, m][\pkvrf_i]$, forward the message to $ \simulator $. Upon receiving $ (\msg{Verified}, \sid,\pkring, m, y, \pi, b') $ from $ \simulator $. Set $ b = b' $. If $ b' = 1 $, append $ \pi $ to $ \prooflist[\pkring, m][\pkvrf_i] $.
 					\item If there exists $\pi \in \prooflist[\pkring, m][\pkvrf_i]$, set $b = 1$.
 				\end{itemize}
-				 Finally, output $(\msg{verified}, \sid, \pkring, m, y, \pi, b)$ to the party.
+				Finally, output $(\msg{verified}, \sid, \pkring, m, y, \pi, b)$ to the party.
 			\end{description}
 			\par\hrulefill\\
 			We add the following linking procedures:
 			\begin{description}
 				\item[Linking proof.] upon receiving a message $(\msg{link}, \sid, \pkring, \pkrvrf_i, m, y,\pi)$ from $\user_i$, check that $\pkrvrf_i \in \pkring$ and that $\pkrvrf_i $ is associated to $\user_i$ in $ \vklist $. 
-				Check whether $\evaluationslist[\pkring, m][\pkvrf_i] = y$ and $ \pi \in \prooflist[\pkring, m][\pkrvrf_i] $. If any of the above fails, ignore the request.
-				Send $(\msg{link}, \sid, \pkring, m, y)$ to $\simulator$. Upon receiving $(\msg{linkproof}, \sid, \pkring, m, y, \hat \pi)$ from $\simulator$, append $\hat\pi$ to $\Linklist[\pkring, m, \pi][\pkvrf_i]$ and return $(\msg{linked}, \sid, y, \hat\pi)$ to $\user_i$.
+				Check whether $\evaluationslist[\pkring, m][\pkvrf_i] = y$ and $ \pi \in \prooflist[\pkring, m][\pkrvrf_i] $. If any of the above fails, ignore the request. Otherwise,
+				send $(\msg{link}, \sid, \pkring, m, y)$ to $\simulator$. Upon receiving $(\msg{linkproof}, \sid, \pkring, m, y, \hat \pi)$ from $\simulator$, append $\hat\pi$ to $\Linklist[\pkring, m, \pi][\pkvrf_i]$ and return $(\msg{linked}, \sid, \pkring, \pkrvrf_i, m, y,\pi, \hat\pi)$ to $\user_i$.
 				%\item[Malicious linking proof.] upon receiving a message $(\msg{link}, \sid, \pkring, m, y)$ from $\simulator$, check that $\vklist$ has a key set for $\simulator$, and that it is in $R$.
 				%Check that $\evaluationslist[\pkring, m][\simulator] = y$.
 				%If any of the above is not satisfied, ignore the request.
-- 
2.34.1

