\begin{figure}
	\scriptsize
	\begin{tcolorbox}
		{  \begin{description}
				\item[Key Generation.] upon receiving a message $(\msg{keygen}, \sid)$ from a party $\user_i$, send $(\msg{keygen}, \sid, \user_i)$ to the simulator $\simulator$.
				Upon receiving a message $(\msg{verificationkey}, \sid, \pkrvrf)$ from $\simulator$, verify that $\pkrvrf$ has not been recorded before; then, store in the table $\vklist$, under $\user_i$, the value $\pkrvrf$.
				Return $(\msg{verificationkey}, \sid, \pkrvrf)$.
				
				\item[Malicious Key Generation.] upon receiving a message $(\msg{keygen}, \sid, \pkrvrf)$ from $\simulator$, verify that $\pkrvrf$ was not yet recorded, and if so record in the table $\vklist$ the value $\pkrvrf$ under $\simulator$. Else, ignore the message.
				
				\item[VRF Evaluation.] upon receiving a message $(\msg{eval}, \sid, \pkring, \pkvrf_i, m)$ from $\user_i$, verify that $\pkrvrf_i \in \pkring$ and if there exists $ \pkvrf_i $ in $\vklist $ associated with $ \user_i $. If that was not the case, just ignore the request.
				If $\evaluationslist[\pkring, m][\pkrvrf_i]$ is empty, then sample a new $y \sample \bin^{\ell(\secpar)}$ and store the pair $y$ in the array associated to the message $m$ and the ring $\pkring$. That is, store $\evaluationslist[\pkring, m][\pkrvrf_i] = y$.
				Let sets $\prooflist[\pkring, m][\pkrvrf_i] = \emptylist$ and $\Linklist[\pkring, m][\pkrvrf_i] = \emptylist$ if $ \prooflist[\pkring, m][\pkrvrf_i] $ and $\Linklist[\pkring, m][\pkrvrf_i] = \emptylist$ do not exits. Return $(\msg{evaluated}, sid, \pkring, m, y)$ to $ \user_i $.
				
				
				\item[VRF evaluation and proof.] upon receiving a message $(\msg{evalprove}, \sid, \pkring, \pkrvrf_i, m)$ from $\user_i$, verify that $\pkrvrf_i \in \pkring$ and that there exists a public key $\pkrvrf_i$ associated to $\user_i$ in the table $ \vklist $. If that wasn't the case, just ignore the request.
				Send $(\msg{evalprove}, \sid, \pkring, m)$ to $\simulator$. Upon receiving $(\msg{eval}, \sid, \pkring, m, \pi)$ as a response from $\simulator$, if $\evaluationslist[\pkring, m][\pkrvrf_i]$ is not set, select $y \sample \bin^{\ell(\secpar)}$ and set $\evaluationslist[\pkring, m][\pkrvrf_i]$ to be $y$; set $\prooflist[\pkring, m][\pkrvrf_i] = \set{\pi}$. Otherwise, let $y \defeq \evaluationslist[\pkring, m][\pkrvrf_i]$; update the list of proofs $\prooflist[\pkring, m][\pkrvrf_i]$ by adding $\pi$. Return $(\msg{evaluated\&proved}, \sid, \pkring,m, y, \pi)$ to $\user_i$.
				
				%\item[Malicious VRF evaluation.] upon receiving a message $(\msg{evalprove}, \sid, \pkring, m)$ from $\simulator$, check that $\vklist$ has a public key associated to $\simulator$. If not, ignore the request. If $\evaluationslist[\pkring, m][\simulator]$ is not set, sample $y \sample \bin^{\ell(\secpar)}$ and set $\evaluationslist[\pkring, m][\simulator] \defeq y$ (and $\prooflist[\pkring,m]$ to $\emptyset$). If $\prooflist[\pkring, m]$ contains a proof (i.e., if $\prooflist[\pkring, m]$ is not empty), return $(\msg{evaluated}, \sid, y)$ to $\simulator$. Else, ignore the request.
				
				%\item[Verification.] upon receiving a message $(\msg{verify}, \sid, \pkring, m, y, \pi)$, from any party forward the message to the simulator. If there exists a $\pkrvrf_i$ among the values of \texttt{verification\_keys}, and there exists $\pi \in \prooflist[\pkring, m]$, set $b = 1$. Else, set $b =0$. Finally, output $(\msg{verified}, \sid, \pkring, m, y, \pi, b)$.
				\item[Verification.] upon receiving a message $(\msg{verify}, \sid, \pkring, m, y, \pi)$, set $ b = 0 $ and check if there exists a  $\pkrvrf_i \in \pkring$ and  in $ \vklist $ such that $ \evaluationslist[\pkring,m][\pkvrf_i] = y $. 
				\begin{itemize}
					\item If not, set $ b = 0 $.
					\item If there exists a $ \pkrvrf_i $ such that $ \evaluationslist[\pkring,m][\pkvrf_i] = y$, $ \pkrvrf_i $ is a malicious key and   $\pi \notin \prooflist[\pkring, m][\pkvrf_i]$, forward the message to $ \simulator $. Upon receiving $ (\msg{Verified}, \sid,\pkring, m, y, \pi, b') $ from $ \simulator $. Set $ b = b' $. If $ b' = 1 $, append $ \pi $ to $ \prooflist[\pkring, m][\pkvrf_i] $.
					\item If there exists $\pi \in \prooflist[\pkring, m][\pkvrf_i]$, set $b = 1$.
				\end{itemize}
				 Finally, output $(\msg{verified}, \sid, \pkring, m, y, \pi, b)$ to the party.
			\end{description}
			\par\hrulefill\\
			We add the following linking procedures:
			\begin{description}
				\item[Linking proof.] upon receiving a message $(\msg{link}, \sid, \pkring, \pkrvrf_i, m, y,\pi)$ from $\user_i$, check that $\pkrvrf_i \in \pkring$ and that $\pkrvrf_i $ is associated to $\user_i$ in $ \vklist $. 
				Check whether $\evaluationslist[\pkring, m][\pkvrf_i] = y$ and $ \pi \in \prooflist[\pkring, m][\pkrvrf_i] $. If any of the above fails, ignore the request.
				Send $(\msg{link}, \sid, \pkring, m, y)$ to $\simulator$. Upon receiving $(\msg{linkproof}, \sid, \pkring, m, y, \hat \pi)$ from $\simulator$, append $\hat\pi$ to $\Linklist[\pkring, m, \pi][\pkvrf_i]$ and return $(\msg{linked}, \sid, y, \hat\pi)$ to $\user_i$.
				%\item[Malicious linking proof.] upon receiving a message $(\msg{link}, \sid, \pkring, m, y)$ from $\simulator$, check that $\vklist$ has a key set for $\simulator$, and that it is in $R$.
				%Check that $\evaluationslist[\pkring, m][\simulator] = y$.
				%If any of the above is not satisfied, ignore the request.
				%Return $(\msg{linked}, \sid, y)$ to $\simulator$.
				\item[Linking verification.] upon receiving a message $(\msg{verifylink}, \sid, \pkrvrf_i, \pkring, m, y,\pi,\hat\pi)$ from any party forward the message to the simulator, if there exists a $\pkrvrf_i$ among the values of $ \vklist $, and $\evaluationslist[\pkring, m][\pkvrf_i] = y$, and $\Linklist[\pkring, m, \pi][\pkvrf_i]$ contains $\hat\pi$, set $b=1$. Else, set $b=0$. Return $(\msg{verified}, \sid, \pkrvrf_i, \pkring, m, y, \hat\pi, b).$ to the party.
			\end{description}
		}
	\end{tcolorbox}
	\caption{Functionality $\fgvrf$.\label{f:gvrf}}
\end{figure}
