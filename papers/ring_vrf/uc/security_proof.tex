\section{Security Proof of Our Protocol in UC}
Before we start to analyse our protocol, we should define the algorithms $ \gen_{sign} $ and $ \gen_W $ for $ \fgvrf $. $ \fgvrf $ that \name \ realizes runs Algorithm \ref{alg:genW} to generate  anonymous keys and Algorithm \ref{alg:gensign} to generate signatures.



\begin{algorithm}
	\caption{$\gen_{W}(\comring,\pk,m)$}
	\label{alg:genW}	 	
	\begin{algorithmic}[1]
		\State$ W \sample\GG $
		%		\State \textbf{get} $ X \in \pk $
		%		\If{$\mathtt{DB}[m, \comring] = \perp  $}		
		%		\State{$ a \sample \FF_p $}		
		%		\State{$\mathtt{DB}[m, \comring] := a$}
		%		\EndIf
		%		\State$ a \leftarrow \mathtt{DB}[m, \comring] $
		%		
		%		\State \textbf{return} $ aX $
		\State \textbf{return} $ W $
	\end{algorithmic}
	
\end{algorithm}

\begin{algorithm}
	\caption{$\gen_{sign}(\comring,W,\pk,m)$}
	\label{alg:gensign}	 	
	\begin{algorithmic}[1]
		\State $ c,s,\delta \sample \FF_p $
		\State $ \beta \sample \FF_p $
		\State $ C =  \pk + \beta G_2$
		%\State $ \pi_{com} \leftarrow \nizk.\mathsf{Simulate}(\rcom, (G_1, G_2, \GG,C,W,P)) $
		\State $ \pi_{com}  \leftarrow (c,s,\delta)$
		%\State \textbf{send} $(\msg{learn\_\tau},\sid)  $ to $ \gcrs $
		%\State \textbf{receive} $(\msg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
		\State $ \pi_{MT} \leftarrow \nizk.\mathsf{Prove}(\rsnark, ((X, \beta),(G_1,G_2, \GG,\comring, C))) $ 
		\State\Return$ \sigma = (\pi_{com},\pi_{MT},C,W) $
	\end{algorithmic}
	
\end{algorithm}

Clearly, $ \gen_{W} $ and $ \gen_{sign} $ satisfy the anonymity defined in Definition \ref{def:anonymity} because $ W $ and $ \sigma $ are generated independent from the public key $ \pk $.


We next show that \name \ realizes $ \fgvrf $  in the random oracle model under the assumption of the hardness of the decisional Diffie Hellman (DDH).

%The GDH problem is solving the computational DH problem by accessing the Diffie-Hellman oracle ($ \mathsf{DH}(.,.,.) $) which tells that given triple $ X,Y,Z $ is a DH-triple i.e., $ Z = xyG $ where $ X = xG $ and $ Y = yG $.

%\begin{definition}[$ n $-One-More Gap Diffie-Hellman (OM-GDH) problem]
%	Given   $ p $-order group $ \GG $ generated by $ G $, the challenges $ G, X = xG, P_1, P_2, \ldots, P_{n+1} $ and access to the DH oracle $ \mathsf{DH}(.,.,.) $ and the oracle $ \mathcal{O}_x(.) $ which returns $ xP $ given input $ P $, if a PPT adversary $ \mathcal{A} $ outputs $ xP_1, xP_2, \ldots, xP_{n+1} $ with the access of at most $ n $-times to the oracle $ \mathcal{O}_x $, then $ \mathcal{A}  $ solves the $ n $-OM-GDH problem. We say that $ n $-OM-GDH problem is hard in $ \GG $, if for all PPT adversaries, the probability of solving the $ n $-OM-GDH problem is negligible in terms of the security parameter.
%\end{definition}

\begin{theorem}
	Assuming that $ \hashG, \hash,\hash' $ are random oracles,  the DDH problem is hard in the group structure $ (\GG, G_1,G_2, p) $ and NIZK algorithms are zero-knowledge and knowledge sound, \name \ UC-realizes $\fgvrf$ according to Definition \ref{def:uc}.
\end{theorem}

\begin{proof}
	We construct a simulator $ \simulator $ that simulates the honest parties in the execution of \name \ and simulates the adversary in $ \fgvrf $. 
	\begin{itemize}
		%\item \textbf{[Simulation of $ \gcrs $:] }When simulating $ \gcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rsnark) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $. Whenever a party comes to learn the $ crs $, $ \simulator $ gives $ crs $ as  $ \gcrs $.
		
		\item \textbf{[Simulation of $ \msg{keygen} $:]} Upon receiving $(\msg{keygen}, \sid, \user_i)$ from $\fgvrf$, $ \simulator $ samples $x \sample \FF_p$ and obtains the key $X = xG$. It adds $ xG $ to lists $ \hkeys $ and $ \vklist $ as a key of $ \user_i $. 
		In the end, $ \simulator $ returns $(\msg{verificationkey}, \sid, X)$ to $\fgvrf$. %Whenever the honest party $ \user $ is corrupted by $ \env, $ $ \simulator $ moves the key of $ \user $ to $ \malkeys $ from $ \hkeys $.
		
		\item \textbf{[Simulation of corruption:]} Upon receiving a message $ (\msg{corrupted}, \sid, \user_i) $ from $ \fgvrf $, $ \simulator $ removes the public key $ X $ from $ \hkeys $ which is stored as a key of $ \user_i $ and adds $ X $ to $ \malkeys $.
		
		\item\textbf{[Simulation of the random oracles:]} We  describe how $ \simulator $ simulates the random oracles $ \hashG, \hash $ against the real world adversaries. 	$ \simulator $ simulates  $ \hash' $  as a usual random oracle.
		
		
		$ \simulator $ simulates the random oracle $ \hashG $ as described in Figure \ref{oracle:Hg}. It selects a random element  $ h $ from $ \FF_p $ for each new input and outputs $ hG_1 $ as an output of the random oracle $ \hashG $. Thus, $ \simulator $ knows \emph{the discrete logarithm of each random oracle output of $\hashG  $}. 
		\begin{figure}
			\centering
			
			\noindent\fbox{%
				\parbox{7cm}{%
					\underline{\textbf{Oracle $ \hashG $}} \\
					\textbf{Input:} $ m, \comring $ \\
					\textbf{if} $\mathtt{oracle\_queries\_gg}[m, \comring] = \perp  $
					
					\tab{$ h \sample \FF_p $}
					
					%					\tab{\textbf{for all} $ X \in \comring $}
					%					
					%					\tab{$ W =  hX $}
					%					
					%					\tabdbl{\textbf{if} $ W \in \anonymouskeylist $: \textsc{Abort}}
					%					
					%					\tabdbl{\textbf{else:} \textbf{add} $ W $ \textbf{to} $ \anonymouskeylist $}
					
					\tab{$ P \leftarrow hG_1 $} 
					
					\tab{$\mathtt{oracle\_queries\_gg}[m, \comring] := h$}
					
					\textbf{else}:
					
					\tab{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \comring] $}
					
					\tab{$ P \leftarrow hG_1$}
					
					\textbf{return $ P $}
					
			}}	
			\caption{The random oracle $ \hashG $}
			\label{oracle:Hg}
		\end{figure}
		
		The simulation of the random oracle $ \hash $ is less straightforward (See Figure \ref{oracle:H}). Whenever an input $ (m, \comring, W) $ is given to $ \hash $, it first obtains the discrete logarithm $ h $ of $ \hashG(m, \comring) $ from the $ \hashG $'s database. It needs this information to obtain a public key  which could be used when running $ \rvrf.\sign $. Remark that if $ W $ is a pre-output generated as described in $ \rvrf.\sign $, it should be equal to $ x\hashG(m, \comring)= xhG_1 $  where $ xG_1 $ is a public key. Therefore, the random oracle $ \hash $ obtains first  a  key $ X^* = h^{-1}W $ to check whether it is an honest key. 
		%If $ X^* $ has not been registered as a malicious key, it registers it to $ \fgvrf $. Thus, $ \simulator $ has a right to ask the output of the message $ m, \comring $ to $ \fgvrf $. 
		If $ X^*$ is not an honest key generated by $ \simulator $, $ \simulator $ considers the input $ (m,\comring,W) $ as an attempt to learn the output of the ring signature of the message $ m $, the ring $ \comring $ and the pre-output $ W $.
		Remark that if $ X^* $ is not an honest key, $ \sim $ has a right to ask the output of $ m $ with the public key $ X^* $ and the ring $ \comring $. Therefore, $ \simulator $ sends the message $ (\msg{eval}, \sid, \comring,W,m) $ to $ \fgvrf $ and receives the message $ (\msg{evaluated}, \sid, \comring,W,m,y) $.
		After learning the evaluation output $ y $, it sets $ y $ as the answer of the random oracle $ \hash $  for the input $ (m, \comring, W) $. 
		% Remember that $ \fgvrf $ only replies to the evaluation message of $ \sim $ if $ W $ is not mapped to another message, ring and public key $ (m', \comring', X')   $. $ W $ cannot be map to $ (m', \comring', X')   \neq  (m, \comring, X*)   $ because it would be aborted during the simulation $ \hashG $ if they were mapped to $ W $.
		If $ X^* $ is registered as an honest party's key, $ \simulator $ outputs a randomly selected element. 
		
		
		\begin{figure}
			\centering
			
			\noindent\fbox{%
				\parbox{9cm}{%
					\underline{\textbf{Oracle $ \hash$}} \\
					\textbf{Input:} $ m, \comring,W $ 
					
					\textbf{if} $ \mathtt{oracle\_queries\_h}[m, \comring, W] \neq \perp $
					
					\tab{\textbf{return $  \mathtt{oracle\_queries\_h}[m, \comring, W] $}}
					
					$ P \leftarrow \hashG(m,\comring) $\\			
					$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \comring] $\\
					$ X^* := h^{-1}W $ // candidate verification key 
					
					{\textbf{if} $ X^* \notin \hkeys$ } 
					
					\tab{\textbf{send} $ (\msg{eval}, \sid, \comring, W, X^*, m) $ \textbf{to} $ \fgvrf $}
					
					\tab{\textbf{receive} $ (\msg{evaluated}, \sid, \comring,W, m, y) $ \textbf{from} $ \fgvrf $}
					
					\tab{$  \mathtt{oracle\_queries\_h}[m, \comring, W]:=y $}
					
					\textbf{else}
					
					\tab{$ y \sample \FF_p $}
					
					\tab{$  \mathtt{oracle\_queries\_h}[m, \comring, W]:=y $}
					%					{\textbf{else:} $ \mathtt{oracle\_queries\_h}[m, \comring, W]  = \perp$}
					%					
					%					%\tab{\textbf{return} \textsc{Abort}}
					%					\tab{$ y \sample \bin^\lambda $}
					%					
					%					\tab{$\mathtt{oracle\_queries\_h}[m, \comring, W] := y $}
					
					\textbf{return $  \mathtt{oracle\_queries\_h}[m, \comring, W] $}
					
			}}	
			\caption{The random oracle $ \hash $}
			\label{oracle:H}
		\end{figure}
		
		%		\item \textbf{[Simulation of $ \msg{sign} $]} 
		%		The simulator has a table  $\preoutputlist $ to keep the pre-outputs that it selects for each input and the ring of public keys. 
		%		Upon receiving $(\msg{sign}, \sid, \comring, m, y)$  from the functionality $\fgvrf$, $ \simulator $ generates the signature $ \sigma $ as follows:
		%		
		%		For the first proof, it samples $ c, s, \delta \in \FF_p $ and $ C, W \in \GG$. Then, it lets the first proof be $\pi_1 =  (c, s, \delta) $. 
		%		In addition, it sets $ R = sG_1+ \delta G_2+ cC $ and $ R_m = s \hashG(m, \comring)+ cW $ and maps the input $ \comring,m, W,C, R, R_m$ to $ c $ in the table of the random oracle $ \hash' $ so that $ \pi_1 $ verifies in the real-world execution.  
		%		It adds $ W $ to the list $ \preoutputlist[m, \comring] $.
		%		
		%		$ \simulator $ gets the trapdoor $ \tau $ that it generated during the simulation of $ \gcrs $ to simulate the second proof. Then, it runs $ \mathsf{SNARK}.\mathsf{Simulate}(\rsnark,\tau, crs) $ and obtains $ \pi_2 $.
		%		
		%		In the end, $ \simulator $  responds by sending the message $(\msg{signature}, \sid, \comring, m, \sigma = (\pi_1, \pi_2, C, W))$ to the $ \fgvrf $.  It also lets $ \mathtt{oracle\_queries\_h}[m, \comring, W] $ be $ y $, if it is not defined yet. If it is defined with another value $ y' \neq y $, then it aborts.
		%TODO: Talk about this abort case happens with a negl probability. 
		
		\item \textbf{[Simulation of $ \msg{verify} $]} Upon receiving  $(\msg{verify}, \sid, \comring,W, m, \sigma)$ from the functionality $\fgvrf$, $ \simulator $ runs the two NIZK verification algorithms run for $ \rcom, \rsnark $ with the input $ \comring, m, \sigma, W $ described in $ \rvrf.\verify $ algorithm of \name. If  all verify, it sets $ b_{\simulator} =1 $. Otherwise it sets $ b_{\simulator} =0  $.
		
		\begin{itemize}
			\item 		If $ b_\simulator = 1 $, it sets $ X = h^{-1} W$ where $ h = \mathtt{oracle\_queries\_gg}[m, \comring] $ and sends  $ (\msg{verified}, \sid, \comring, W, m, \sigma, b_\simulator, X) $ to $ \fgvrf $ and receives back $ (\msg{verified}, \sid, \comring, W, m, \sigma, y, b) $. 
			\begin{itemize}
				\item If $ b \neq b_\simulator $, it means that the signature is not a valid signature in the ideal world, while it is in the real world. So, $ \simulator $ aborts in this case.
				
				If $ \fgvrf $ does not verify a ring signature even if  it is verified in the real world, $ \fgvrf $ is in either \ref{cond:consistency}, \ref{cond:uniqueness} or \ref{cond:forgery}.
				If $ \fgvrf $ is in \ref{cond:uniqueness}, it means that $ \counter[m,\comring] > |\comring_m| $. If $ \fgvrf $ is in \ref{cond:forgery}, it means that $ X $ belongs to an honest party but this honest party never signs $ m $ for the ring $ \comring $. So, $ \sigma $ is a forgery.	If $ \fgvrf $ is in  \ref{cond:consistency} and sets $ b =0 $, it means that $ m, W, \comring, \sigma $ was recorded as invalid by $ \fgvrf $, but now $ m, W, \comring, \sigma $ is a valid signature in the real world. 
				This case never happens because of the correctness of $ \nizk $ algorithms. 
				% In short, if $ \sim $ aborts because $ b\neq b_\sim $ it means either $ W $ of an honest party is not unique and $ \adv $ in the real world generates a forgery signature of $ (m, \comring, \sigma) $ with $ W $ or the adversary in the real world generates anonymous keys for $ (m, \comring) $ more than the number of adversarial keys in $ \comring $.
				%				 
				
				\item If $ b = b_\simulator $, set $ \mathtt{oracle\_queries\_h}[m, \comring,W] = y $. Here, if $ \sigma $ is a signature of an honest party, $ \simulator $ sets its output with respect to the output selected by $ \fgvrf $. 
				%    Remark that we do not need to set $ \mathtt{oracle\_queries\_h\_schnor} $ because it already verifies in the real world.
			\end{itemize}
			\item If $ b_\simulator = 0 $, it sets $ X = \perp $ and sends  $ (\msg{verified}, \sid, \comring, W, m, \sigma, b_\simulator, X) $ to $ \fgvrf $. Then, $ \sim $ receives back $ (\msg{verified}, \sid, \comring, W, m, \sigma, y, b) $. 
			\begin{itemize}
				\item If $ b \neq b_\simulator $, it means that it was a signature of an honest party and $ \nizk.\verify $ for $ \rcom $ does not validate in the real world. So, $ \simulator $ sets $ \mathtt{oracle\_queries\_h}[m, \comring,W] = y $ and $ \mathtt{oracle\_queries\_h\_schnor}[\comring, m, W, C, R', R_m'] = c $ where $ R' = sG_1 + \delta G_2+ cC  $, $ R_m = s \hashG(m,\comring) + cW$. 
				Now, the signature verifies in the real world as well.
				\item If $ b = b_\simulator $, $ \simulator $ doesn't need to do anything.
			\end{itemize}
			
		\end{itemize}
		
		
		
		
		
		\item \textbf{[Simulation of $ \msg{link} $:]} Upon receiving $(\msg{link}, \sid, \comring, W,X_i, m,  \sigma)$ from $\fgvrf$, $ \sim $ runs $ \nizk.\simulate(\rel_{dleq}, (G_1, \GG,X_i, P,W)) $ and obtains $ \hat{\sigma} $.
		
		%		it picks random $ \hat s, \hat c $ and lets $ (X_i, m, \hat sG_1-\hat cX_i, \hat s\hashG(m, \comring)- \hat cW) $ be $ \hat c $ in the table of the random oracle $ \hash' $. It sends $ (\msg{link}, \sid, X_i,(\hat s,\hat c)) $ to $ \fgvrf $. Also, if $ \hash(m,\comring, W) $ is not defined, it sets $ \mathtt{oracle\_queries\_h}[m, \comring, W] = y$. If it is defined but not equal to $ y $, it aborts.
		
		
		\item \textbf{[Simulation of $ \msg{verifylink} $:]} Upon receiving  $(\msg{verifylink}, \sid, \pk, \comring, W,m, \sigma, \hat \sigma)$ from the functionality $\fgvrf$,  it runs $ \rvrf.\link\verify(\pk,\comring, m, \sigma,\hat \sigma) \rightarrow b_\simulator $ and  returns $ (\msg{verified}, \sid, \pk,\comring, m, \sigma, \hat\sigma, b_\simulator) $ to  $\fgvrf  $. Then, $ \fgvrf $ replies with $ (\msg{verified}, \sid, \pk,\comring,W, m, \sigma, \hat\sigma, b) $. 
		
		If $ b' \neq b_\simulator   = 1 $ and $ \pk \in \mathtt{honest\_verification\_keys} $, then $ \simulator $ aborts. If this happens, it means that a link signature for $ \sigma $ has not been yet generated for $ m, \comring $ by an honest party with a key $ \pk $ in the ideal world.
		
		We remark that the other cases:   $ (b' \neq b_\simulator   = 1, \pk \in \mathtt{malicious\_verification\_keys})$ and  $ b \neq b_\simulator = 0 $ cannot happen thanks to  the correctness of $ \nizk $. The first case  means that $ \rvrf.\link\verify(\pk,\comring, m, \sigma,\hat \sigma) \rightarrow 0$ before, but now $  \rvrf.\link\verify(\pk,\comring, m, \sigma,\hat \sigma) \rightarrow 1 $.  
		The second case $ b \neq b_\simulator = 0 $ is not possible also because if $ \pk $ is an honest key, its link signature is generated by $ \simulator $ so $ \rvrf.\link\verify $ always verifies it . If $ \pk $ is a malicious key then $ \fgvrf $ outputs  $ b_\simulator $ if it was not set 0 before. 
		
		
		%If $ b = 1 $, obtain $ X^* = h^{-1}W $ where $ W \in \sigma $ and $ h = \mathtt{oracle\_queries\_gg}[m, \comring] $. If  $ \pk \in \mathtt{malicious\_verification\_keys} $ and $ \pk \neq X^* $, then it aborts. In addition, if  $ \pk \notin \mathtt{malicious\_verification\_keys} $ and $ \pk = X^* $, then it aborts. 
		%NOTE: if the the key is malicious then W should be generated properly. If it is not generated properly i.e X^* \neq \pkoops and the linkverify outputs 1, then the soundness is broken. Also, if \pkoops is a honest key but X^* = pk, then it aborts because W is not generated properly for honest parties.
		%Otherwise, it returns $ (\msg{verified}, \sid, \pk,\comring, m, \sigma, \hat\sigma, b) $ to  $\fgvrf  $. 
		
		%\item \textbf{[Simulation of outputs of ideal honest parties:]} Whatever an honest party outputs in the ideal-world, $ \simulator $ outputs the same in the real-world simulation as an output of the same honest party. 
		%If an honest party outputs a signature $ \comring, m, \sigma $, 	it sends $ (\msg{verify}, \sid, \comring, m, \sigma) $ to $ \fgvrf $. If $ \fgvrf $ verifies it, $ \simulator $ receives $ y $. Then, it sets $ \mathtt{oracle\_queries\_h}[m, \comring, W] $ as $ y $ if $ \mathtt{oracle\_queries\_h}[m, \comring, W] $ is not defined. If $ \mathtt{oracle\_queries\_h}[m, \comring, W] $ was already defined with another value, $ \simulator $ aborts.  
		%NOTE: We don't need this anymore because honest evaluation value is always assigned during signing.
		%Similarly,  If an honest party outputs a link-signature $ \pk, \comring, m, \sigma, \hat \sigma $, 	it sends $ (\msg{verifylink}, \sid, \pk,\comring, m, \sigma, \hat \sigma) $ to $ \fgvrf $. If $ \fgvrf $ verifies it, $ \simulator $ obtains $ X^* = h^{-1}W  $ where $ h = \mathtt{oracle\_queries\_gg}[m, \comring] $ and $ W \in \sigma $. If $ X^* \neq \pk $, it aborts. 
		
		%		 If the honest party's output is an evaluation value $ y $ and a proof $ \pi $ of an input $ m, \comring $, $ \simulator $ checks whether the proof $ \pi $ of the evaluation $ y $ with the input $ m, \comring $ is valid. For this,
		%		% it checks whether $ \prooflist[\pi] $ is assigned to an input $ m $ and a ring key set $ \comring $. If it is the case, 
		%		it sends $ (\msg{verify}, \sid, \comring, m, y, \pi) $ to $ \fgvrf $. If $ \fgvrf $ verifies it, $ \simulator $ retrieves $ W $ from $ \pi $ and sets $ \mathtt{oracle\_queries\_h}[m, \comring, W] $ as $ y $ if $ \mathtt{oracle\_queries\_h}[m, \comring, W] $ is not defined. $ \mathtt{oracle\_queries\_h}[m, \comring, W] $ was already defined with another value, $ \simulator $ aborts. 
		
		%		\item \textbf{[Simulation of honest parties in the real protocol]} $ \simulator $ behaves as described in the real protocol while simulating the honest parties except the following cases: 
		%		\begin{itemize}
			%			\item When $ \adv $ sends $ \comring,m,y, \pi $ where $ \rvrf.\verify(\comring, m, y, \pi) \rightarrow 1$ where $ (\pi_1, \pi_2, C,W) $, $ \simulator $ checks whether it is a forgery as follows: It obtains $ h = \mathtt{oracle\_queries\_gg}[m, \comring] $ and learns $ X^{*} = h^{-1}W $ which is supposed to be a verification key of the evaluation $ y $. If $ X^* \notin \comring $ or $ X^* \notin \mathtt{malicious\_verification\_keys}$, it aborts. Otherwise, it continues as described in the protocol. 
			%			\item When $ \adv $ sends $ X, \comring, m,y, \pi, \pi_{\link} $ where $ \rvrf.\link\verify(X, \comring, m,y, \pi, \pi_{\link}) \rightarrow 1$, $ \simulator $ checks whether it is a forgery as follows: It obtains $ h = \mathtt{oracle\_queries\_gg}[m, \comring] $ and learns $ X^{*} = h^{-1}W $ which is supposed to be a verification key of the evaluation $ y $. If $ X^* \neq X $, then it aborts.
			%		\end{itemize}		
		%		 
	\end{itemize}
	
	\begin{theorem}\label{thm:rvrf}
		\name \ over the group structure $ (\GG,p,G_1,G_2) $ realizes $ \fgvrf $ in Figure \ref{f:gvrf} in the random oracle model assuming that NIZK is zero-knowledge and knowledge extractable, the decisional Diffie-Hellman (DDH) problem are hard in $ (\GG,p,G_1,G_2)  $. 
	\end{theorem}
	
	\begin{proof}
		
		We first show that the outputs of honest parties in the ideal world are indistinguishable from the output of honest parties in the real protocol. 
		
		\begin{lemma}\label{lem:honestoutput}
			Assuming that DDH problem is hard on the group structure $ (\GG, G_1,G_2,p) $, the outputs of honest parties in the real protocol \name\ are indistinguishable from the output of the honest parties in $ \fgvrf $.
		\end{lemma}
		
		\begin{proof}
			Clearly, the link signatures and outputs of the ring signatures in the ideal world identical to the real world protocol because the link signature is generated by $ \simulator $ as in the real protocol and the outputs are randomly selected by $ \fgvrf $ as the random oracle $ \hash $ in the real protocol. The only difference is the generation of the ring signature (See Algorithm \ref{alg:gensign}) and the anonymous key (See Algorithm \ref{alg:genW}). The distribution of $ \pi_{com} = (c,s,\delta) $ and $ C $ generated by Algorithm \ref{alg:gensign} and the distribution of $ \pi_{com} = (c,s,\delta) $ and $ C $ generated by $ \rvrf.\sign $ are from uniform distribution so they are indistinguishable. Thanks to the zero-knowledge property of NIZK, $ \pi_{MT} $ generated by Algorithm \ref{alg:gensign} and $ \pi_{MT} $ generated by $ \rvrf.\sign $ are indistinguishable too.  
			
			Now, we show that the anonymous key $ W $ generated by Algorithm \ref{alg:genW} and $	 W $ generated by $ \rvrf.\sign $ are indistinguishable. For this,  we need show that selecting $ W $ randomly from $ \GG $ and computing $ W $ as $x \hashG(m, \comring) $ are indistinguishable.
			We  show this under the assumption that the DDH problem  is hard.  In other words, we show that if there exists an adversary $ \adv' $ that distinguishes anonymous keys of honest parties in the ideal world and anonymous key of the honest parties in the real protocol then we construct another adversary $ \bdv $ which breaks the DDH problem. 
			We use the hybrid argument to show this.
			We define hybrid simulations $ H_{i} $ where  the anonymous keys of first $ i $ honest parties are computed as described in $ \rvrf.\sign $ and the rest are computed by selecting them randomly. Without loss of generality, $ \user_1, \user_2, \ldots, \user_{n_h} $ are the honest parties. Thus, $ H_0 $ is equivalent to the anonymous keys of the ideal protocol  and $ H_{n_h}  $ is equivalent to the anonymous keys of honest parties in the real world.  We construct an adversary $ \bdv $ that breaks the DDH problem given that there exists an adversary $ \adv' $ that distinguishes hybrid games $ H_i $ and $ H_{i + 1} $ for $ 0 \leq i < n_h $. $\bdv $ receives the DDH challenges $ X,Y, Z \in \GG $ from the DDH game and simulates the game against $ \adv' $ as follows: $\bdv $ generates the public key of all  honest parties' key as usual by running $ \rvrf.\keygen$ except party $ \user_{i+1} $. It lets $ \user_{i+1} $'s public key be $ X $. $ \bdv $ gives $ \GG, G_1 = Y, G_2 $ as parameters of \name. 
			
			%		\begin{figure}
				%		\centering
				%		
				%		\noindent\fbox{%
					%			\parbox{8cm}{%
						%				\underline{\textbf{Oracle $ \hashG $ in \ref{game:DDH} by the DDH adversary $\simulator $}} \\
						%				\textbf{Input:} $ m, \comring $ \\
						%				\textbf{if} $\mathtt{oracle\_queries\_gg}[m, \comring] = \perp  $
						%				
						%				\tab{$ h \sample \FF_p $}
						%				
						%				\tab{\fbox{$ P \leftarrow hY $}}
						%				
						%				\tab{$\mathtt{oracle\_queries\_gg}[m, \comring] := h$}
						%				
						%				\textbf{else}:
						%				
						%				\tab{h $\leftarrow \mathtt{oracle\_queries\_gg}[m, \comring]$}
						%				
						%				\tab{\fbox{$ P \leftarrow hY $}}
						%				
						%				\textbf{return $ P $}
						%				
						%		}}	
				%		\caption{The simulation of the random oracle $ \hashG $ by $\simulator $. The different steps than Figure \ref{oracle:Hg} are in the box.}
				%		\label{oracle:HgbyB}
				%		\end{figure}
			
			$\bdv $ simulates the ring signatures of first $ i $ parties as in the real protocol and the parties $ \user_{i+2}, \ldots, \user_{n_h} $ as follows: it generates a ring signature and its anonymous key by running Algorithm \ref{alg:gensign} and Algorithm \ref{alg:genW}. It generates the link signatures of $ \user_{i+2}, \ldots, \user_{n_h} $ by running $ \nizk.\simulate(\rel_{dleq}, (G_1, \GG,X_i, P,W)) $. The simulation of $ \user_{i + 1} $ is different. It lets the public key of $ \user_{i + 1} $ be $ X$. Whenever $ \user_{i+1} $ needs to sign an input $ m, \comring $, it obtains $ P = \hashG(m, \comring) = hY $ from $ \mathtt{oracle\_queries\_gg} $ and lets $ W = hZ $. Remark that if $ (X,Y,Z)$ is a DH triple (i.e., $  \mathsf{DH}(X,Y,Z) \rightarrow 1 $), $ \user_{i+1} $ is simulated as in \name \ because $ W = xP $ in this case. Otherwise, $ \user_{i+1} $ is simulated as in the ideal world because $ W $ is random. So, if $  \mathsf{DH}(X,Y,Z)  \rightarrow 1$, $\simulator $ simulates $ H_{i+1} $. Otherwise, it simulates $ H_{i} $. In the end of the simulation, if $ \adv $ outputs $ i $, $\simulator $ outputs $ 0 $ meaning $  \mathsf{DH}(X,Y,Z) \rightarrow 0$. Otherwise, it outputs $ i + 1 $. The success probability of $\simulator $ is equal to the success probability of $ \adv' $ which distinguishes $ H_i $ and $ H_{i +1} $. Since DDH problem is hard, $\simulator $ has negligible advantage in the DDH game. So, $ \adv' $ has a negligible advantage too. Hence, from the hybrid argument, we can conclude that $ H_0    $ which corresponds the output of honest parties in  \name\ and $ H_q  $ which corresponds to  the output of honest parties in ideal world are indistinguishable.
			
			This concludes the proof of showing the output of honest parties in the ideal world are indistinguishable from the output of the honest parties in the real protocol.
		\end{proof}	
		
		Next we show that the simulation executed by $ \simulator $ against $ \adv $ is indistinguishable from the real protocol execution.
		
		\begin{lemma} 
			The view of $ \adv $ in its interaction with the simulator $ \simulator $ is indistinguishable from the view of $ \adv $ in its interaction with real honest parties.
		\end{lemma}
		
		
		\begin{proof}
			The  simulation against the real world adversary $ \adv $ is identical to the real protocol except the output of the honest parties and cases where $ \simulator $ aborts. We have already shown in Lemma \ref{lem:honestoutput} that the output of honest parties are indistinguishable from the real protocol. Next, we show that the abort cases happen with negligible probability during the simulation. In other words, we show that if there exists an adversary $ \adv $ which makes $ \simulator $ abort during the simulation, then we construct another adversary $ \bdv $ which breaks the CDH problem. 
			
			Consider a CDH game in the group prime $ p $-order group  $ \GG $ with the challenges $ G_1,U, V \in \GG$. The CDH challenges are given to the simulator $ \bdv $. Then $ \bdv $ runs a simulated copy of $ \env $ and starts to simulate $ \fgvrf $ and $ \simulator $ for $ \env $. For this, it first runs the simulated copy of $ \adv $ as $ \simulator $ does. $ \bdv $ provides $ (\GG, p, G_1 , G_2) $ as a public parameter of the ring VRF protocol to $ \adv $.
			
			Whenever $ \bdv $ needs to generate a ring signature for $ m, \comring $ on behalf of an honest party with a public key $ X $, it runs  Algorithm \ref{alg:genWbdv} to generate the corresponding anonymous key of the honest party and Algorithm \ref{alg:gensignbdv}. 
			
			\begin{algorithm}
				\caption{$\gen_{W}(\comring,X, m)$}
				\label{alg:genWbdv}	 	
				\begin{algorithmic}[1]
					\If{$ DB_W[m,\comring, X] = \perp $}
					\State $ W \sample \GG$
					\State $ DB_W[m,\comring, X] := \perp $
					\State \textbf{add} $ W $ to list $ \anonymouskeylist[m,\comring] $
					\EndIf
					\State \textbf{return} $ DB_W[m,\comring, X] $
				\end{algorithmic}
			\end{algorithm}
			
			
			\begin{algorithm}
				\caption{$\gen_{sign}(\comring,W,X,m)$}
				\label{alg:gensignbdv}	 	
				\begin{algorithmic}[1]
					\State $ c,s,\delta \sample \FF_p $
					\State $ \beta \sample \FF_p $
					\State $ C =  X + \beta G_2$
					\State $ R' = sG_1 +\delta G_2 + cC$
					\State $ R_m = s\hashG(m, \comring) + c W $
					\State $ \mathtt{oracle\_queries\_h\_schnor}[\comring,m, W, C,R',R'_m] = c$						
					\State $ \pi_{com} \leftarrow (c,s,\delta) $
					%\State \textbf{send} $(\msg{learn\_\tau},\sid)  $ to $ \gcrs $
					%\State \textbf{receive} $(\msg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
					\State $ \pi_{\pk} \leftarrow  \nizk.\prove(\rsnark,((X, \beta),(G_1,G_2, \GG,\comring, C))) $
					\State \textbf{return} $ \sigma = (\pi_{com},\pi_{MT},C,W) $
				\end{algorithmic}
				
			\end{algorithm}
			
			Whenever $ \bdv $ needs to generate a link signature for an honest party, it runs $ \mathsf{NIZK}.\mathsf{Simulate}(\rel_{dleq},(G_1,\GG, X,P,W)) $ as $ \simulator $ does.
			
			Clearly the ring signature of an honest party outputted by $ \sim $ (remember $ \fgvrf$ generates it by Algorithm \ref{alg:gensign}) and the ring signature generated by $ \bdv $ are indistinguishable because NIZK is zero knowledge.
			
			In order to generate the public keys of honest parties, $ \bdv $ picks a random $ r_x\in \ZZ_p $ and generates the public key of each honest party as $ r_xV$.
			Remark that $ \bdv$  never needs to know the secret key of honest parties to simulate them since $ \bdv $ selects anonymous keys randomly  and generates the ring signatures and link signatures  without the secret keys. Therefore, generating the honest public keys in this way is indistinguishable. 			
			\begin{figure}
				\centering
				
				\noindent\fbox{%
					\parbox{9cm}{%
						\underline{\textbf{Oracle $ \hash$}} \\
						\textbf{Input:} $ m, \comring,W $ 
						
						\textbf{if} $ \mathtt{oracle\_queries\_h}[m, \comring, W] = \perp $
						
						\tab{$ y \sample \{0,1\}^{\ell_\rvrf} $}
						
						\tab{$  \mathtt{oracle\_queries\_h}[m, \comring, W]:=y $}
						
						
						\textbf{return $  \mathtt{oracle\_queries\_h}[m, \comring, W] $}
						
				}}	
				\caption{The random oracle $ \hash $}
				\label{oracle:HbyB}
			\end{figure}
			
			\begin{figure}
				\centering
				
				\noindent\fbox{%
					\parbox{7cm}{%
						\underline{\textbf{Oracle $ \hashG $}} \\
						\textbf{Input:} $ m, \comring $ \\
						\textbf{if} $\mathtt{oracle\_queries\_gg}[m, \comring] = \perp  $
						
						\tab{$ h \sample \FF_p $}
						
						
						\tab{$ P \leftarrow hU $} 
						
						\tab{$\mathtt{oracle\_queries\_gg}[m, \comring] := h$}
						
						\textbf{else}:
						
						\tab{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m, \comring] $}
						
						\tab{$ P \leftarrow hU$}
						
						\textbf{return $ P $}
						
				}}	
				\caption{The random oracle $ \hashG $}
				\label{oracle:HgbyB}
			\end{figure}
			
			Simulation of $ \hashG $ is as described in Figure \ref{oracle:HgbyB} i.e., it returns $ hU $ instead of $ hG_1 $. The simulation of $ \hashG $ is indistinguishable from the simulation of $ \hashG $ in Figure \ref{oracle:Hg}. 
			$ \bdv $ simulates the random oracle $ \hash $ in Figure \ref{oracle:HbyB} a usual random oracle. The only difference from the simulation of $ \hash $ by $ \simulator $ is that $ \bdv $ does not ask for the output of $ \hash(m,\comring,W) $ to $ \fgvrf $. This difference is indistinguishable from the simulation of $ \hash $ by $ \simulator $ because $ \simulator $ gets it from $ \fgvrf $ which selects it randomly as $ \bdv  $ does. Remark that since $ \hashG $ is not simulated as in Figure \ref{oracle:Hg}, $ \bdv $ cannot check whether $ W $ is an anonymous key generated by an honest key or not.  
			
			During the simulation whenever a valid signature $ \sigma = (\pi_{com},\pi_{\pk},C,W) $ of message $ m $ signed by $ \comring $ is outputted and $ W \notin \anonymouskeylist[m,\comring] $ (i.e., $ W $ is not generated by $ \bdv $), $ \simulator $ increments a counter $ \counter[m,\comring] $ and adds $ W $ to $ \anonymouskeylist[m,\comring] $.
			Then it runs $ \mathsf{Ext}(\rsnark,\pi_{\pk_j},(G_1,G_2, \GG,\comring, C_j) ) \rightarrow X_j, \beta_j$ where $ X_j\in \comring $ and $ C_j = X_j + \beta_j G_2 $ and $ \mathsf{Ext}(\rcom,\pi_{com_j},(G_1,G_2, \GG,\comring, C_j,W_j,\hashG(m,\comring))) \rightarrow (\hat{x}_j,\hat{\beta}_j )$ such that $ C_j = \hat{x}_jG_1 + \hat{\beta}_j G_2 $ and $ W_j = \hat{x}_j \hashG(m,\comring) $. 
			
			If $ X_j  $ is an honest public key and $ X_j = \hat{x}_jG_1 $, $ \bdv $ solves the CDH problem as follows: $ W = \hat{x}_j h U $ where $ h = \mathtt{oracle\_queries\_gg}[m, \comring] $. Since $ X_j = r_j V $, $ W = \hat{x}_jhuG_1 =r_jhuV $. So, $ \bdv $ outputs $ r_j^{-1}h^{-1}W $ as a CDH solution and simulation ends. Remark that this case happens when $ \simulator $ aborts because of \ref{cond:forgery}.
			
			If $  \counter[m,\comring] = t \geq |\comring_\adv| $, $ \bdv $ obtains all the signatures $ \{\sigma_i\}_{i =1}^t $ that make $ \bdv $ increment $ \counter[m,\comring] $ and solves the CDH problem as follows: Remark that this case happens when $ \simulator $ aborts because of \ref{cond:uniqueness}.
			
			For all $ \sigma_j = (\pi_{com_j},\pi_{\pk_j},C_j,W_j) \in \{\sigma_i\}_{i =1}^t $, $ \bdv $ runs $ \mathsf{Ext}(\rsnark,\pi_{\pk_j},(G_1,G_2, \GG,\comring, C_j) ) \rightarrow X_j, \beta_j$ where $ X_j\in \comring $ and $ C_j = X_j + \beta_j G_2 $. One of the following cases happens:
			
			\begin{itemize}
				\item All $ X_j$'s are different: If $ \bdv $ is in this case, it means that there exists one public key $ X_a $ which is honest. Then $ \bdv $ runs $ \mathsf{Ext}(\rcom,\pi_{com_a},(G_1,G_2, \GG,\comring, C_a,W_a,\hashG(m,\comring))) \rightarrow (\hat{x}_a,\hat{\beta}_a )$ such that $ C_a = \hat{x}_aG_1 + \hat{\beta}_a G_2 $ and $ W_a = \hat{x}_a \hashG(m,\comring) $.  If $ \bdv $ is in this case, $ \hat{x}_aG_1\neq X_a $ because otherwise it would solve the CDH as described before. Therefore, $ \beta_a \neq \hat{\beta}_a $. Since $ X_a + \beta_a G_2 = \hat{x}_aG_1 + \hat{\beta}_a G_2  $ and $ X_a = r_aV $ where $ r_a $ is generated by $ \bdv $ during the key generation process, $ \bdv $ obtains a representation of $ V = \gamma G_1 + \delta G_2 $ where $ \gamma = \hat{x}_ar^{-1}_a  $ and $ \delta = (\hat{\beta}_a -\beta)r_a^{-1} $. Then $ \bdv $ stores $ (\gamma, \delta) $ to a list $ \mathsf{rep} $. If $ \mathsf{rep} $ does not include another element $ (\gamma', \delta')  \neq (\gamma, \delta) $, $ \bdv $ rewinds $ \adv $ to the beginning with a new random coin.  Otherwise, it obtains $ (\gamma', \delta') $ which is another representation of $ V $ i.e., $ V = \gamma' G_1 + \delta' G_2 $. Thus, $ \bdv $ can find discrete logarithm of $ V $ on base $ G_1 $ which is $ v = \gamma + \delta \theta $ where $ \theta = (\gamma - \gamma')(\delta' - \delta)^{-1} $. $ \bdv $ outputs $ vU $ as a CDH solution and the simulation ends.
				
				
				\item There exists at least two $ X_a,X_b $ where $ X_a = X_b $. $ \bdv $ runs $ \mathsf{Ext}(\rcom,\pi_{com_a},(G_1,G_2, \GG,\comring, C_a,W_a,\hashG(m,\comring))) \rightarrow (\hat{x}_a,\hat{\beta}_a )$ and $ \mathsf{Ext}(\rcom,\pi_{com_b},(G_1,G_2, \GG,\comring, C_b,W_b,\hashG(m,\comring))) \rightarrow (\hat{x}_b,\hat{\beta}_b )$ such that $ C_a = \hat{x}_aG_1 + \hat{\beta}_a G_2, C_b = \hat{x}_bG_1 + \hat{\beta}_b G_2 $ and $ W_a = \hat{x}_a \hashG(m,\comring), W_b = \hat{x}_b \hashG(m,\comring) $. Since $ W_a \neq W_b $, $ \hat{x}_a \neq \hat{x}_b $.  Therefore, $ \bdv $ can obtain  two different and non trivial representation of $ X_a = X_b $ i.e., $ X_a = X_b = \hat{x}_aG_1 + (\hat{\beta}_a - \beta_a) G_2 = \hat{x}_bG_1 + (\hat{\beta}_b - \beta_b) G_2  $. Thus, $ \bdv $ finds the discrete logarithm of $ G_2 = U $ in base $ G_1 $ which is $ u = \frac{\hat{x}_a - \hat{x}_b}{\hat{\beta}_a -\beta_a -\hat{\beta}_b + \beta_b} $. $ \bdv $ outputs $ uV $ as a CDH solution.
			\end{itemize}
			
			
			
			
			
			
			
			
			
			
			
			
			%	
			%		
			%		
			%			$ \bdv $ solves CDH if $ \bdv $ is in the abort case of simulation of $ \hash$ in Figure \ref{oracle:H} by outputting $ r^{-1}h^{-1}W $ is the CDH solution of $ U,V $. $ r^{-1}h^{-1}W $ is the CDH solution because $ vU $ is a solution of $ CDH $ where $ V =  $
			%		
			%		is in this case $ \bdv $ outputs  $ r^{-1}h^{-1}W $  where $ X^* = rV $ and $ h = \mathtt{oracle\_queries\_gg}[m,\comring] $ and simulation ends. Remark that if $ \bdv $ aborts during the simulation of $ \hash $ it means that $ X^* $ belongs to an honest party and $ X^* =  h^{-1}W = rV = rvG_1$.  Therefore, $ r^{-1}h^{-1}W $ is the CDH solution of $ U,V $.
			%				  
			%		During the simulation if $ \bdv $ sees a valid forgery ring signature  $ m, \comring, \sigma = (\pi_{com}, \pi_{MT}, C, W) $ where $ W $ is an anonymous key generated by $ \bdv $ for $ (m',\comring') \neq (m, \comring) $, $ \bdv $ aborts. $ \Pr[x\hashG(m',\comring') = W; xG_1 \in \comring'| \comring',W] $ is negligible because $ \hashG $ is a random oracle.
			%		%TODO exact probability
			%				  
			
			%		During the simulation if $ \bdv $ sees a forgery ring signature  $ m, \comring, \sigma = (\pi_{com}, \pi_{MT}, C, W) $ where $ X = h^{-1}W $ is an honest key, then $ \bdv $ does the following: It runs the extractor algorithms on $ \pi_{MT} $ i.e., $ \ext(\rsnark,..) $ and obtains $ X' \in \comring $ and $ \beta' $ where $ C = X' + \beta' G_2 $ and $ \pi_{com} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \beta$ where $ C = xG_1 + \beta G_2$ and $ W = x\hashG(m, \comring)= xhV$.  Then, $ \bdv $ outputs the CDH of $ U, V $ which is $r^{-1}xU  $. This is correct CDH solution because $ X= rV = xG_1 $, $ V= r^{-1}xG_1 $.
			%		We remark  a forgery signature corresponds to the abort case of $ \simulator $ during the verification because $ \fgvrf $ is in \ref{cond:forgerymalicious}, $ \pk_\simulator  $ is an honest party's key. 
			
			%		During the simulation if $ \bdv $ sees $  k > |\comring_m| $-valid and malicious ring signatures $ \{\sigma_1, \sigma_2, \ldots,\sigma_k\} $ of the message $ m$ signed by $\comring $ whose anonymous keys are $ \{W_1, W_2, \ldots, W_k\} $, respectively , it runs $ \ext(\rsnark,..) $ for each valid malicious signatures $ \sigma_i $(signatures that are not generated by $ \bdv $) and obtains $ \beta'_i, X'_i \in \comring $. In this case, the one of following two cases must happen:
			%		
			%		\begin{itemize}
				%			\item There exists $ X'\in \comring$ which is an honest key. In this case, $ \bdv  $ runs $ \pi_{com} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \beta$ and stores $ r V = x^*G_1 + (\beta - \beta')G_2 = x^*G_1 + b G_2$ to $DB $. If $ DB $ is empty, rewind $ \adv $ to the beginning of the simulation. If it is not empty i.e., there exists $ \hat{r}X = \hat{x} G_1 + \hat{b}G_2 $, then $ \bdv $ first checks whether $ r = \hat{r} $. If it is the case, it aborts. If it is not the case, it finds the discrete logarithm of $ G_1=U $ on base $ G_2 $ which is $ t = \frac{\hat{r}^{-1}\hat{b}^*-{r}^{-1}b}{{r}^{-1}\hat{x}-\hat{r}^{-1}\hat{x}} $.  Then, it outputs the CDH of $ U,V $ which is $ tV $. 
				%			We remark that $ \bdv $ aborts after rewinding with a negligible probability because it selects $ r $ randomly.
				%			%TODO exact probability
				%			\item  There exists $ X' \in \comring$ which is the  output of two different signatures.
				%		\end{itemize}
			%		
			%		
			%		During the simulation if $ \bdv $ sees a valid ring signature  $ m, \comring, \sigma = (\pi_{com}, \pi_{MT}, C, W) $ where $ X = h^{-1}W \notin \comring$, then $ \bdv $ does the following: It runs the extractor algorithms on $ \pi_{MT} $ i.e., $ \ext(\rsnark,..) $ and obtains $ X' \in \comring $ and $ \beta' $ where $ C = X' + \beta' G_2 $ and $ \pi_{com} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \beta$ where $ C = xG_1 + \beta G_2$ and $ W = x\hashG(m, \comring)= xhV$. In this case, $ X \neq X' $, so $ \beta \neq \beta' $. 
			%				  
			%				  
			%		\begin{itemize}
				%			\item If $ X' $ is honest, then store $ r V = x^*G_1 + (\beta - \beta')G_2 = x^*G_1 + b G_2$ to $DB $. If $ DB $ is empty, rewind $ \adv $ to the beginning of the simulation. If it is not empty i.e., there exists $ \hat{r}X = \hat{x} G_1 + \hat{b}G_2 $, then $ \bdv $ first checks whether $ r = \hat{r} $. If it is the case, it aborts. If it is not the case, it finds the discrete logarithm of $ G_1=U $ on base $ G_2 $ which is $ t = \frac{\hat{r}^{-1}\hat{b}^*-{r}^{-1}b}{{r}^{-1}\hat{x}-\hat{r}^{-1}\hat{x}} $.  Then, it outputs the CDH of $ U,V $ which is $ tV $. 
				%			We remark that $ \bdv $ aborts after rewinding with a negligible probability because it selects $ r $ randomly.
				%			%TODO exact probability
				%				  	
				%			\item If $ X' $ is  a malicious key, $ \bdv $ runs the extractor algorithm on PoK proof $ \pi_{dl} $ of $ X' $ i.e., $ \ext(\rdl,..,) $ which outputs $ x' $ where $ X' = x'G_1 $. Since $ x' \neq x^* $, $ \bdv  $ has a Pedersen commitment $ C $ with two openings so it can find the discrete logarithm of $ G_2$ on base $ G_1 $ which is $ t = \frac{x^* - x'}{\beta' - \beta^*} $.  In the end, it outputs the CDH of $ X,Y $ which is $ tU $. 
				%
				%		 \end{itemize}
			%		
			%	
			So, the probability of $ \bdv $ solves the CDH problem is equal to the probability of $ \adv $ breaks the forgery or uniqueness in the real protocol. Therefore,  if there exists $ \adv $ that makes $ \sim$ aborts, then we can construct an adversary $ \bdv $ that solves the CDH problem except with a negligible probability.
			
			
			\qed	  
		\end{proof}
		
	\end{proof}
\end{proof}
