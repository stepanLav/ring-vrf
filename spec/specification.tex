% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\author{}
\date{}

\begin{document}

\hypertarget{bandersnatch-vrfs}{%
\section{Bandersnatch VRFs}\label{bandersnatch-vrfs}}

\hypertarget{introduction}{%
\subsection{Introduction}\label{introduction}}

\textbf{Definition}: A \emph{verifiable random function with additional
data (VRF-AD)} can be described with four functions:

\begin{itemize}
\tightlist
\item
  \(VRF.KeyGen: () \mapsto (pk,sk)\) where \(pk\) is a public key and
  \(sk\) is its corresponding secret key.
\item
  \(VRF.Sign : (sk,msg,ad) \mapsto \pi\) takes a secret key \(sk\), an
  input \(msg\), and additional data \(ad\), and returns a VRF signature
  \(\pi\).
\item
  \(VRF.Eval : (sk, msg) \mapsto Out\) takes a secret key \(sk\) and an
  input \(msg\), and returns a VRF output \(out\).
\item
  \(VRF.Verify: (pk,msg,aux,\pi) \mapsto (out|prep)\) for a public key
  \(pk\), an input \(msg\), and additional data \(ad\), and then returns
  either an output \(out\) or else failure \(perp\).
\end{itemize}

\textbf{Definition}: For an elliptic curve \(E\) defined over finite
field \(F\) with large prime subgroup \(G\) generated by point \(g\), an
EC-VRF is VRF-AD where \(pk = sk \cdot g\) and \(VRF.Sign\) is based on
an elliptic curve signature scheme.

All VRFs described in this specification are EC-VRF.

For input \(msg\) and \(ad\) additional data first we compute the
\(VRFInput\) which is a point on elliptic curve \(E\) as follows:
\[ t \leftarrow Transcript(msg) \]
\[ VRFInput := H2C(challange(t, "vrf-input") \]

Where: - \(transcript\) function is described in
{[}{[}ark-transcript{]}{]} section. - \(H2C: B \rightarrow G\) is a hash
to curve function correspond to curve \(E\) specified in Section
{[}{[}hash-to-curve{]}{]} for the specific choice of \(E\)

\hypertarget{vrf-input}{%
\subsubsection{VRF Input}\label{vrf-input}}

The VRF Input is a point on the elliptic curve E and generated as output
of the Elligator 2 hash-to-curve algorithm as described by section 6.8.2
of \href{https://datatracker.ietf.org/doc/rfc9380/}{RFC9380}. The
algorithm yields a point which is inside the prime order subgroup of E.

\hypertarget{vrf-preoutput-and-output}{%
\subsubsection{VRF Preoutput and
Output}\label{vrf-preoutput-and-output}}

\textbf{Definition}: \emph{VRF pre-output} is generated using VRF input
point as:

\[ PreOutput \leftarrow sk \cdot VrfInput \]

\textbf{Definition}: \emph{VRF output} is generated using \emph{VRF
pre-output} point as:
\[ VrfOutput \leftarrow Hash("vrfoutput", Encode(PreOutput)) \]

\hypertarget{ietf-vrf}{%
\subsection{IETF VRF}\label{ietf-vrf}}

Definition of a VRF based on the IETF
\href{https://www.rfc-editor.org/rfc/rfc9381}{RFC-9381}.

All the details specified by the RFC applies with the additional
capability to add additional data (\texttt{ad}) as per definition of
EC-VRF we've given. In particular the step 5 of section 5.4.3 is defined
as:

\begin{verbatim}
str = str || ad || challenge_generation_domain_separator_back
\end{verbatim}

\hypertarget{bandersnatch-cipher-suite-configuration}{%
\subsubsection{Bandersnatch Cipher Suite
Configuration}\label{bandersnatch-cipher-suite-configuration}}

Configuration follows the RFC-9381 suite specification guidelines.

\begin{itemize}
\item
  The EC group G is the Bandersnatch elliptic curve, in Twisted Edwards
  form, with the finite field and curve parameters as specified in the
  \href{https://neuromancer.sk/std/bls/Bandersnatch}{neuromancer}
  standard curves database. For this group, \texttt{fLen} =
  \texttt{qLen} = 32 and \texttt{cofactor} = 4.
\item
  The prime subgroup generator \texttt{g} is constructed following
  Zcash's guidelines: \emph{``The generators of G1 and G2 are computed
  by finding the lexicographically smallest valid x-coordinate, and its
  lexicographically smallest y-coordinate and scaling it by the cofactor
  such that the result is not the point at infinity.''}

  \begin{itemize}
  \tightlist
  \item
    g.x =
    \texttt{0x29c132cc2c0b34c5743711777bbe42f32b79c022ad998465e1e71866a252ae18}
  \item
    g.y =
    \texttt{0x2a6c669eda123e0f157d8b50badcd586358cad81eee464605e3167b6cc974166}
  \end{itemize}
\item
  The public key generation primitive is \texttt{PK\ =\ SK\ Â·\ g}, with
  \texttt{SK} the secret key scalar and \texttt{g} the group generator.
  In this ciphersuite, the secret scalar \texttt{x} is equal to the
  secret key \texttt{SK}.
\item
  \texttt{suite\_string} = 0x33.
\item
  \texttt{cLen} = 32.
\item
  \texttt{encode\_to\_curve\_salt} = \texttt{PK\_string}.
\item
  The \texttt{ECVRF\_nonce\_generation} function is as specified in
  Section 5.4.2.1 of RFC-9381.
\item
  The \texttt{int\_to\_string} function encodes into the 32 bytes little
  endian representation.
\item
  The \texttt{string\_to\_int} function decodes from the 32 bytes little
  endian representation.
\item
  The point\_to\_string function converts a point on E to an octet
  string using compressed form. The Y coordinate is encoded using
  \texttt{int\_to\_string} function and the most significant bit of the
  last octet is used to keep track of the X's sign. This implies that
  the point is encoded on 32 bytes.
\item
  The string\_to\_point function tries to decompress the point encoded
  according to \texttt{point\_to\_string} procedure. This function MUST
  outputs ``INVALID'' if the octet string does not decode to a point on
  the curve E.
\item
  The hash function Hash is SHA-512 as specified in
  \href{https://www.rfc-editor.org/rfc/rfc6234}{RFC6234}, with hLen =
  64.
\item
  The \texttt{ECVRF\_encode\_to\_curve} function (\emph{Elligator2}) is
  as specified in Section 5.4.1.2, with \texttt{h2c\_suite\_ID\_string}
  = \texttt{"BANDERSNATCH\_XMD:SHA-512\_ELL2\_RO\_"}. The suite must be
  interpreted as defined by Section 8.5 of
  \href{https://datatracker.ietf.org/doc/rfc9380/}{RFC9380} and using
  the domain separation tag
  \texttt{DST\ =\ "ECVRF\_"\ \textbar{}\textbar{}\ h2c\_suite\_ID\_string\ \textbar{}\textbar{}\ suite\_string}.
\end{itemize}

\hypertarget{pedersen-vrf}{%
\subsection{Pedersen VRF}\label{pedersen-vrf}}

Pedersen VRF resembles EC VRF but replaces the public key by a Pedersen
commitment to the secret key, which makes the Pedersen VRF useful in
anonymized ring VRFs, or perhaps group VRFs.

\hypertarget{pedersen-vrf-1}{%
\subsection{Pedersen VRF}\label{pedersen-vrf-1}}

Strictly speaking Pederson VRF is not a VRF. Instead, it proves that the
output has been generated with a secret key associated with a blinded
public (instead of public key). The blinded public key is a
cryptographic commitement to the public key. And it could unblinded to
prove that the output of the VRF is corresponds to the public key of the
signer.

\hypertarget{setup}{%
\subsubsection{Setup}\label{setup}}

PedersenVRF is initiated for prime subgroup \(G < E\) of an elliptic
curve E with \(K, B \in G\) are defined to be \emph{key base} and
\emph{blinding base} respectively.

\hypertarget{pedersenvrf.sign}{%
\subsubsection{PedersenVRF.Sign}\label{pedersenvrf.sign}}

\textbf{Inputs}:\\
- Transcript \(t\) of \texttt{ArkTranscript} type\\
- \(input\): \(VRFInput \in G\). - \(sb\): Blinding coefficient
\(\in F\)\\
- \(sk\): A VRF secret key.\\
- \(pk\): VRF verification key corresponds to \(sk\).\\
\textbf{Output}:\\
- A Quintuple \((compk, KBrand, PORand, ks, bs)2\) corresponding to
PedersenVRF signature

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(AddLabel(t, "PedersenVRF")\)
\item
  \(compk = sk*G + sb*B\)
\item
  AppendToTranscript(``KeyCommitment'')
\item
  AppendToTranscript(t, compk)
\item
  \(krand \leftarrow RandomElement(F)\)
\item
  \(brand \leftarrow RandomElement(F)\)
\item
  \(KBrand \leftarrow krand * G + brand * B\)
\item
  \(POrand \leftarrow krand * input\)
\item
  \(AppendToTranscript(t, "Pedersen R")\)
\item
  \(AppendToTranscript(t, "PedersenVrfChallenge")\)
\item
  \(c \rightarrow GetChallengeFromTranscript(t)\)
\item
  \(ks \rightarrow krand + sk * c\)
\item
  \(bs \rightarrow brand + c * sb\)
\item
  \textbf{return} \((compk, KBrand, PORand, ks, bs)\)
\end{enumerate}

\hypertarget{pedersenvrf.verify}{%
\subsubsection{PedersenVRF.Verify}\label{pedersenvrf.verify}}

\textbf{Inputs}:\\
- \(t\): Transcript of \texttt{ArkTranscript} type\\
- \(input\): \(VRFInput \in G\).\\
- \(preout\): \(VRFPreOutput \in G\).\\
- \((compk, KBrand, PORand, ks, bs)\) the quintuple results of
PeredersonVRF.Sign\\
\textbf{Output}:\\
- True if Pedersen VRF signature verifys False otherwise.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Append\((t, "PedersenVRF")\)\\
Append\((t, ""KeyCommitment")\)\\
Append\((t, compk)\)\\
\(z1 \leftarrow POrand + c \times PreOut - In \times ks\)
Append\((t, "Pedersen R")\)\\
Append\((t, KBrand || PORand)\)\\
\(c \leftarrow Challenge(t, "PedersenVrfChallenge")\)\\
\(z1 \leftarrow POrand + c \times preoutput - input \times ks\)\\
\(z1 \leftarrow ClearCofactor(z1)\)\\
\textbf{if} \(z1 \neq O\) \textbf{then} \textbf{return} False\\
\(z2 \leftarrow KBrand + c \times compk - krand \times K - brand \times B\)\\
\(z2 \leftarrow ClearCofactor(z1)\)\\
\textbf{if} \(z2 \neq O\) \textbf{then} \textbf{return} False
\textbf{else} \textbf{return} True

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\end{document}
