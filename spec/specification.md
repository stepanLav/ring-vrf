# Bandersnatch VRFs

## Introduction

**Definition**: A *verifiable random function with additional data (VRF-AD)*
can be described with four functions:

- $VRF.KeyGen: () \mapsto (pk,sk)$ where $pk$ is a public key and $sk$ is
  its corresponding secret key.
- $VRF.Sign : (sk,msg,ad) \mapsto \pi$ takes a secret key $sk$, an input $msg$,
  and additional data $ad$, and returns a VRF signature $\pi$.
- $VRF.Eval : (sk, msg) \mapsto Out$ takes a secret key $sk$ and an input $msg$,
  and returns a VRF output $out$.
- $VRF.Verify: (pk,msg,aux,\pi) \mapsto (out|prep)$ for a public key $pk$,
  an input $msg$, and additional data $ad$, and then returns either an output
  $out$ or else failure $perp$.

**Definition**: For an elliptic curve $E$ defined over finite field $F$ with
large prime subgroup $G$ generated by point $g$, an EC-VRF is VRF-AD
where $pk = sk \cdot g$ and $VRF.Sign$ is based on an elliptic curve signature
scheme.

All VRFs described in this specification are EC-VRF.

For input $msg$ and $ad$ additional data first we compute the $VRFInput$
which is a point on elliptic curve $E$ as follows:
$$ t \leftarrow Transcript(msg) $$
$$ VRFInput := H2C(challange(t, "vrf-input") $$


Where:
- $transcript$ function is described in [[ark-transcript]] section.
- $H2C: B \rightarrow G$ is a hash to curve function correspond
to curve $E$ specified in Section [[hash-to-curve]] for the specific choice of $E$

### VRF Input

The VRF Input is a point on the elliptic curve E and generated
as output of the Elligator 2 hash-to-curve algorithm
as described by section 6.8.2 of [RFC9380](https://datatracker.ietf.org/doc/rfc9380/).
The algorithm yields a point which is inside the prime order
subgroup of E.

### VRF Preoutput and Output

**Definition**: *VRF pre-output* is generated using VRF input point as:

$$ PreOutput \leftarrow sk \cdot VrfInput $$

**Definition**: *VRF output* is generated using *VRF pre-output* point as:
$$ VrfOutput \leftarrow Hash("vrfoutput", Encode(PreOutput)) $$



## IETF VRF

Definition of a VRF based on the IETF [RFC-9381](https://www.rfc-editor.org/rfc/rfc9381).

All the details specified by the RFC applies with the additional capability to add additional
data (`ad`) as per definition of EC-VRF we've given. In particular the step 5 of section
5.4.3 is defined as:

    str = str || ad || challenge_generation_domain_separator_back

### Bandersnatch Cipher Suite Configuration

Configuration follows the RFC-9381 suite specification guidelines.

* The EC group G is the Bandersnatch elliptic curve, in Twisted Edwards form,
  with the finite field and curve parameters as specified in the [neuromancer](https://neuromancer.sk/std/bls/Bandersnatch)
  standard curves database. For this group, `fLen` = `qLen` = 32 and `cofactor` = 4.

* The prime subgroup generator `g` is constructed following Zcash's guidelines:
  *"The generators of G1 and G2 are computed by finding the lexicographically
  smallest valid x-coordinate, and its lexicographically smallest y-coordinate
  and scaling it by the cofactor such that the result is not the point at infinity."*

  - g.x = `0x29c132cc2c0b34c5743711777bbe42f32b79c022ad998465e1e71866a252ae18`
  - g.y = `0x2a6c669eda123e0f157d8b50badcd586358cad81eee464605e3167b6cc974166`

* The public key generation primitive is `PK = SK Â· g`, with `SK` the secret
  key scalar and `g` the group generator. In this ciphersuite, the secret
  scalar `x` is equal to the secret key `SK`.

* `suite_string` = 0x33.

* `cLen` = 32.

* `encode_to_curve_salt` = `PK_string`.

* The `ECVRF_nonce_generation` function is as specified in Section 5.4.2.1 of RFC-9381.

* The `int_to_string` function encodes into the 32 bytes little endian representation.
 
* The `string_to_int` function decodes from the 32 bytes little endian representation.

* The point_to_string function converts a point on E to an octet
  string using compressed form. The Y coordinate is encoded using
  `int_to_string` function and the most significant bit of the last
  octet is used to keep track of the X's sign. This implies that
  the point is encoded on 32 bytes.

* The string_to_point function tries to decompress the point encoded
  according to `point_to_string` procedure. This function MUST outputs
  "INVALID" if the octet string does not decode to a point on the curve E.

* The hash function Hash is SHA-512 as specified in
  [RFC6234](https://www.rfc-editor.org/rfc/rfc6234), with hLen = 64.

* The `ECVRF_encode_to_curve` function (*Elligator2*) is as specified in
  Section 5.4.1.2, with `h2c_suite_ID_string` = `"BANDERSNATCH_XMD:SHA-512_ELL2_RO_"`.
  The suite must be interpreted as defined by Section 8.5 of [RFC9380](https://datatracker.ietf.org/doc/rfc9380/)
  and using the domain separation tag `DST = "ECVRF_" || h2c_suite_ID_string || suite_string`.

## Pedersen VRF

Pedersen VRF resembles EC VRF but replaces the
public key by a Pedersen commitment to the secret key, which makes the
Pedersen VRF useful in anonymized ring VRFs, or perhaps group VRFs.

## Pedersen VRF

Strictly speaking Pederson VRF is not a VRF. Instead, it proves
that the output has been generated with a secret key associated
with a blinded public (instead of public key). The blinded public
key is a cryptographic commitement to the public key. And it could
unblinded to prove that the output of the VRF is corresponds to 
the public key of the signer.

### Setup

PedersenVRF is initiated for prime subgroup $G < E$ of an elliptic
curve E with $K, B \in G$ are defined to be *key base* and *blinding base*
respectively.

### PedersenVRF.Sign
**Inputs**:  
  - Transcript $t$ of `ArkTranscript` type\
  - $input$: $VRFInput \in G$.
  - $sb$: Blinding coefficient $\in F$\
  - $sk$: A VRF secret key.\
  - $pk$: VRF verification key corresponds to $sk$.\
**Output**:\
  - A Quintuple
      $(compk, KBrand, PORand, ks, bs)2$
      corresponding to PedersenVRF signature

---

1. $AddLabel(t, "PedersenVRF")$
2. $compk = sk*G + sb*B$
3. AppendToTranscript("KeyCommitment")
4. AppendToTranscript(t, compk)
5. $krand \leftarrow RandomElement(F)$
6. $brand \leftarrow RandomElement(F)$
7. $KBrand \leftarrow krand * G + brand * B$
8. $POrand \leftarrow krand * input$
9. $AppendToTranscript(t, "Pedersen R")$
10. $AppendToTranscript(t, "PedersenVrfChallenge")$
11. $c \rightarrow GetChallengeFromTranscript(t)$
13. $ks \rightarrow krand + sk * c$ 
12. $bs \rightarrow brand + c * sb$
14. **return** $(compk, KBrand, PORand, ks, bs)$

### PedersenVRF.Verify  
**Inputs**:  
  - $t$: Transcript of `ArkTranscript` type\
  - $input$: $VRFInput \in G$.  
  - $preout$: $VRFPreOutput \in G$.  
  - $(compk, KBrand, PORand, ks, bs)$ the quintuple results of PeredersonVRF.Sign  
**Output**:  
  - True if Pedersen VRF signature verifys False otherwise.  

---

Append$(t, "PedersenVRF")$  
Append$(t, ""KeyCommitment")$  
Append$(t, compk)$  
$z1 \leftarrow POrand + c \times PreOut - In \times ks$ 
Append$(t, "Pedersen R")$  
Append$(t, KBrand || PORand)$  
$c \leftarrow Challenge(t, "PedersenVrfChallenge")$  
$z1 \leftarrow POrand + c \times preoutput - input \times ks$   
$z1 \leftarrow ClearCofactor(z1)$    
**if** $z1 \neq O$ **then** **return** False  
$z2 \leftarrow KBrand + c \times compk - krand \times K - brand \times B$  
$z2 \leftarrow ClearCofactor(z1)$        
**if** $z2 \neq O$ **then** **return** False **else** **return** True  

---          

