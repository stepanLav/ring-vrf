# Ring VRF

## VRF

**Definition**: A *verifiable random function with auxiliary data (VRF-AD)* can be described with three functions: 

- $VRF.KeyGen: () \mapsto (pk,sk)$ where $pk$ is a public key and $sk$ is its corresponding secret key.
- $VRF.Sign : (sk,msg,aux) \mapsto \sigma$ takes a secret key $sk$, an input $msg$, and auxiliary data $aux$, and then returns a VRF signature $\sigma$.
- $VRF.Eval : (sk, msg) \mapsto Out$ takes a secret key $sk$ and an input $msg$, and then returns a VRF output $Out$.
- $VRF.Verify: (pk,msg,aux,\sigma)\mapsto (Out|prep)$ for a public key pk, an input msg, and auxiliary data aux, and then returns either an output $Out$ or else failure $perp$.

**Definition**: For an elliptic curve $E$ defined over finite field $F$ with large prime subgroup $G$ generated by point $g$, we call a VRF, EC-VRF is VRF-AD where $pk = sk.g$ and $VRF.Sign$ is an elliptic curve signature scheme.

All VRFs described in this specification are EC-VRF.
For input $msg$ and $aux$ auxilary date first we compute the $VRFInput$ which is a point on elliptic curve $E$ as follows:
$$ VRFiput := H2C(ArkTranscript(msg, aux) $$

where
- $ArkTranscript$ function is described in [[ark-transcript]] section.
- $H2C: B \rightarrow G$  is a hash to curve function correspond to curve $E$ specified in Section [[hash-to-curve]] for the specific choice of $E$

## EC VRF Input
The EC-VRF input ultimately is a point on the elliptic curve
as out put of hash of the transcript using arkworks chosen hash
for the given curve.

VRF Input point should always be created locally, either as a hash-to-cuve
output of the transcripto or ocasionally some base point.
It should never be sent over the wire nor deserialized???Do you mean serialized?


**Definition**: *VRF pre-output* is defined to be a point in $G$ in serialized  affine representation 
** Definition **: *VRF InOut* is defined as a pair as follows:
$$(VRF Input, VRF Preoutput)$$



### Preliminaries 


### VRF Key
#### Public key  \
\
A Public key of a VRF is a point on an Elliptic Curve $E$. \
Public key is represented in Affine form and is serialized using Arkwork compressed serialized
format.


### VRF input

VRF input is an ArkTranscript. See ArkTranscript

#### From transcript to point

You need to call challenge and add b"vrf-input" to it. getting random byte (some hash?)
then hash to curve it. 


## DELQ VRF
### Preliminaries
Implements the two relevant verifiable random functions (VRFs) with
associated data (VRF-ADs) which arise from Chaum-Pedersen DLEQ proofs,
polymorphic over Arkworks' elliptic curves.

Thin VRF aka `ThinVrf` provides a regular VRF similar but broadly superior
to ["EC VRF"](https://www.ietf.org/id/draft-irtf-cfrg-vrf-15.html).
Thin VRF support batch verification or half-aggregation exactly like
Schnorr signatures, but which ECVRF lacks.
In essence, thin VRF *is* a Schnorr signature with base point given by
a pseudo-random (Fiat-Shamir) linear combination of base points, while
EC VRF is two linked Schnorr signatures on distinct base points.
Thin VRF should be slightly faster than EC VRF, be similarly sized on
typical Edwards curves, but slightly larger on larger BLS12 curves.
As a rule, new applications should always prefer thin VRF over EC VRF.

Pedersen VRF aka `PedersenVRF` resembles EC VRF but replaces the
public key by a Pedersen commitment to the secret key, which makes the
Pedersen VRF useful in anonymized ring VRFs, or perhaps group VRFs.
We provide both batchable and nonbatchable forms of the Pedresen VRF.
We favor the batchable form because our blinding factors enlarge our
signatures anyways, making the batchable form less significant
proportionally than batchable forms of EV VRF.

As the Pedersen VRF needs two verification equations, we support
DLEQ proofs between two distinct curves provided both have the same
subgroup order.  Around this, we support omitting the blinding factors
for  cross curve DLEQ proofs, like proving public keys on G1 and G2
of a BLS12 curve have the same secret key.



### Thin VRF

### Pedersen VRF
### Pedersen VRF

Strictly speaking Pederson VRF is not a VRF. Instead, it proves
that the output has been generated with a secret key associated
with a blinded public (instead of public key). The blinded public
key is a cryptographic commitement to the public key. And it could
unblinded to prove that the output of the VRF is corresponds to 
the public key of the signer.

### Pedersen VRF Sign
**Inputs**:\
  - Transcript $t$ of `ArkTranscript` type\
  - $inputs$: An array of points on elliptic curve $E$.\
  - $sb$: Blinding coefficient $\in F$\
  - $sk$: A VRF secret key.\
  - $pk$: VRF verification key corresponds to $sk$.\
**Output**:\
  - $signature$: of VRFPreOutput type.

---

1. AddLabel(t, "PedersenVRF")
1. $compk = sk*G + b*K$
1. AddLabel("KeyCommitment")
1. Append(t, compk)
1. $w \leftarrow GeneratePedersenFiatShamir(t,inputs,secret)$
1. $signature \leftarrow GeneratePedersonProof(t,sb,sk,compk)$
1. **return** $signature$


## Bandersnatch VRF

